## Project Structure
The project is organized into the following directories:
```
./
│   ├── bamboo_ta/
│   └── fetchproject.py
│   └── directory_structure.txt
│   └── setup.py
│   └── requirements.txt
│   ├── bamboo_ta/
│   │   └── cycles.py
│   │   └── volume.py
│   │   └── utility.py
│   │   └── momentum.py
│   │   └── candles.py
│   │   └── performance.py
│   │   └── trend.py
│   │   └── volatility.py
│   │   └── bamboo_ta.py
│   │   └── statistics.py
│   │   └── __init__.py
```

Detailed File Contents:

./
    fetchproject.py

    ----- Start of fetchproject.py -----

import os
import fnmatch

def list_files(startpath, exclude_dirs=None, exclude_files=None):
    if exclude_dirs is None:
        exclude_dirs = []
    if exclude_files is None:
        exclude_files = []

    structure = []
    for root, dirs, files in os.walk(startpath):
        # Exclude directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(os.path.join(root, d), pattern) for pattern in exclude_dirs)]
        level = root.replace(startpath, '').count(os.sep)
        indent = ' ' * 4 * (level)
        structure.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            # Exclude files
            if not any(fnmatch.fnmatch(os.path.join(root, f), pattern) for pattern in exclude_files):
                structure.append(f"{subindent}{f}")
                with open(os.path.join(root, f), 'r') as file_content:
                    try:
                        content = file_content.read()
                        structure.append(f"\n{subindent}----- Start of {f} -----\n")
                        structure.append(f"{content}")
                        structure.append(f"{subindent}----- End of {f} -----\n")
                    except:
                        structure.append(f"{subindent}Contents of {f}:\n{subindent}Unable to read file.\n")
    return structure

def create_directory_overview(startpath, exclude_dirs=None, exclude_files=None):
    if exclude_dirs is None:
        exclude_dirs = []
    if exclude_files is None:
        exclude_files = []

    overview = ["## Project Structure\n", "The project is organized into the following directories:\n", "```\n"]
    for root, dirs, files in os.walk(startpath):
        # Exclude directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(os.path.join(root, d), pattern) for pattern in exclude_dirs)]
        level = root.replace(startpath, '').count(os.sep)
        indent = '│   ' * level + "├── " if level > 0 else ""
        overview.append(f"{indent}{os.path.basename(root)}/\n")
        subindent = '│   ' * (level + 1) + "├── "
        for i, d in enumerate(dirs):
            overview.append(f"{subindent}{d}/\n")
        for f in files:
            # Exclude files
            if not any(fnmatch.fnmatch(os.path.join(root, f), pattern) for pattern in exclude_files):
                file_indent = '│   ' * (level + 1) + "└── "
                overview.append(f"{file_indent}{f}\n")
    overview.append("```\n")
    return overview

def save_structure_to_file(startpath, output_file, exclude_dirs=None, exclude_files=None):
    structure = list_files(startpath, exclude_dirs, exclude_files)
    overview = create_directory_overview(startpath, exclude_dirs, exclude_files)
    with open(output_file, 'w') as f:
        for line in overview:
            f.write(line)
        f.write("\nDetailed File Contents:\n\n")
        for line in structure:
            f.write(line + '\n')

if __name__ == "__main__":
    startpath = '.'  # Current directory
    output_file = 'directory_structure.txt'
    
    # Specify directories and files to exclude with wildcards
    exclude_dirs = ['*__pycache__*', './bamboo_ta.egg-info', './build', './dist', './.git', './images']
    exclude_files = ['./BTC_USDT-1d.json', './__init__.py*', './README*', './LICENSE', './**/*.log', '*/.gitignore' , './test.py']
    
    save_structure_to_file(startpath, output_file, exclude_dirs, exclude_files)
    print(f"Directory structure and contents saved to {output_file}")

"""
GPT Prompt:
1. You are a developer with extensive knowledge of Python and Pinescript. You have this project where you are converting Pinscripts into Python functions so that you can use these in a library for further data analysis in python. The project structure and code of the Python code will follow. After that wait for further instructions about the pinescript to convert. Is that understood?

2. The following pinsecript should be converted into a python function. If this pinescript is depending on other indicators from other libraries (e.g. pandas-ta), do not use that, but instead create additional functions that will take care of the missing indicators. If the indicators are already available in the given project, then use these indicators. Is this clear?

3. Further instructions based on output GPT.

"""

    ----- End of fetchproject.py -----

    directory_structure.txt

    ----- Start of directory_structure.txt -----

## Project Structure
The project is organized into the following directories:
```
./
│   ├── bamboo_ta/
│   └── fetchproject.py
│   └── setup.py
│   └── requirements.txt
│   ├── bamboo_ta/
│   │   └── cycles.py
│   │   └── volume.py
│   │   └── utility.py
│   │   └── momentum.py
│   │   └── candles.py
│   │   └── performance.py
│   │   └── trend.py
│   │   └── volatility.py
│   │   └── bamboo_ta.py
│   │   └── statistics.py
│   │   └── __init__.py
```

Detailed File Contents:

./
    fetchproject.py

    ----- Start of fetchproject.py -----

import os
import fnmatch

def list_files(startpath, exclude_dirs=None, exclude_files=None):
    if exclude_dirs is None:
        exclude_dirs = []
    if exclude_files is None:
        exclude_files = []

    structure = []
    for root, dirs, files in os.walk(startpath):
        # Exclude directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(os.path.join(root, d), pattern) for pattern in exclude_dirs)]
        level = root.replace(startpath, '').count(os.sep)
        indent = ' ' * 4 * (level)
        structure.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            # Exclude files
            if not any(fnmatch.fnmatch(os.path.join(root, f), pattern) for pattern in exclude_files):
                structure.append(f"{subindent}{f}")
                with open(os.path.join(root, f), 'r') as file_content:
                    try:
                        content = file_content.read()
                        structure.append(f"\n{subindent}----- Start of {f} -----\n")
                        structure.append(f"{content}")
                        structure.append(f"{subindent}----- End of {f} -----\n")
                    except:
                        structure.append(f"{subindent}Contents of {f}:\n{subindent}Unable to read file.\n")
    return structure

def create_directory_overview(startpath, exclude_dirs=None, exclude_files=None):
    if exclude_dirs is None:
        exclude_dirs = []
    if exclude_files is None:
        exclude_files = []

    overview = ["## Project Structure\n", "The project is organized into the following directories:\n", "```\n"]
    for root, dirs, files in os.walk(startpath):
        # Exclude directories
        dirs[:] = [d for d in dirs if not any(fnmatch.fnmatch(os.path.join(root, d), pattern) for pattern in exclude_dirs)]
        level = root.replace(startpath, '').count(os.sep)
        indent = '│   ' * level + "├── " if level > 0 else ""
        overview.append(f"{indent}{os.path.basename(root)}/\n")
        subindent = '│   ' * (level + 1) + "├── "
        for i, d in enumerate(dirs):
            overview.append(f"{subindent}{d}/\n")
        for f in files:
            # Exclude files
            if not any(fnmatch.fnmatch(os.path.join(root, f), pattern) for pattern in exclude_files):
                file_indent = '│   ' * (level + 1) + "└── "
                overview.append(f"{file_indent}{f}\n")
    overview.append("```\n")
    return overview

def save_structure_to_file(startpath, output_file, exclude_dirs=None, exclude_files=None):
    structure = list_files(startpath, exclude_dirs, exclude_files)
    overview = create_directory_overview(startpath, exclude_dirs, exclude_files)
    with open(output_file, 'w') as f:
        for line in overview:
            f.write(line)
        f.write("\nDetailed File Contents:\n\n")
        for line in structure:
            f.write(line + '\n')

if __name__ == "__main__":
    startpath = '.'  # Current directory
    output_file = 'directory_structure.txt'
    
    # Specify directories and files to exclude with wildcards
    exclude_dirs = ['*__pycache__*', './bamboo_ta.egg-info', './build', './dist', './.git', './images']
    exclude_files = ['./BTC_USDT-1d.json', './__init__.py*', './README*', './LICENSE', './**/*.log', '*/.gitignore' , './test.py']
    
    save_structure_to_file(startpath, output_file, exclude_dirs, exclude_files)
    print(f"Directory structure and contents saved to {output_file}")

    ----- End of fetchproject.py -----

    setup.py

    ----- Start of setup.py -----

from setuptools import setup, find_packages
import os

here = os.path.abspath(os.path.dirname(__file__))

VERSION = '0.0.5'
DESCRIPTION = 'TA library for Pandas'

with open("README.md", "r") as f:
    LONG_DESCRIPTION = f.read()

# Setting up
setup(
    name="bamboo-ta",
    version=VERSION,
    author="DutchCryptoDad (DCD)",
    author_email="<dutchcryptodad@gmail.com>",
    url="https://github.com/DutchCryptoDad/bamboo-ta",
    description=DESCRIPTION,
    long_description_content_type="text/markdown",
    long_description=LONG_DESCRIPTION,
    packages=find_packages(),
    keywords=['python', 'pandas', 'numpy',
              'trading', 'indicator', 'technical analysis'],
    classifiers=[
        "Development Status :: 1 - Planning",
        "Intended Audience :: Developers",
        "Programming Language :: Python :: 3",
        "Operating System :: Unix",
        "Operating System :: MacOS :: MacOS X",
        "Operating System :: Microsoft :: Windows",
    ],
    install_requires=['pandas', 'numpy'],
    extras_require={
        "def": ["pytest", "twine"],
    },
    python_requres=">=3.10",
)

    ----- End of setup.py -----

    requirements.txt

    ----- Start of requirements.txt -----

ta
numpy
pandas
pandas_ta

    ----- End of requirements.txt -----

    bamboo_ta/
        cycles.py

        ----- Start of cycles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of cycles.py -----

        volume.py

        ----- Start of volume.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of volume.py -----

        utility.py

        ----- Start of utility.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *


        ----- End of utility.py -----

        momentum.py

        ----- Start of momentum.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import *
from .volatility import *
# from .utility import *


def Waddah_Attar_Explosion(df, sensitivity=150, fast_length=20, slow_length=40, channel_length=20, mult=2.0):
    """
    Waddah Attar Explosion Indicator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - sensitivity (int): Sensitivity factor for the indicator. Default is 150.
    - fast_length (int): Length for the fast EMA. Default is 20.
    - slow_length (int): Length for the slow EMA. Default is 40.
    - channel_length (int): Length for the Bollinger Bands. Default is 20.
    - mult (float): Standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Call with:
        WAE = bta.Waddah_Attar_Explosion(df)
        df['trend_up'] = WAE['trend_up']
        df['trend_down'] = WAE['trend_down']
        df['explosion_line'] = WAE['explosion_line']
        df['dead_zone_line'] = WAE['dead_zone_line']

    Returns:
    - pd.DataFrame: DataFrame with 'trend_up', 'trend_down', 'explosion_line', and 'dead_zone_line' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    print("DataFrame columns:", df.columns)  # Debug print
    print("First few rows of the DataFrame:\n", df.head())  # Debug print

    # Calculate DEAD_ZONE
    dead_zone = RMA(TR(df), 100) * 3.7
    print("DEAD_ZONE calculated")  # Debug print

    # Calculate MACD
    macd_fast = EMA(df, 'close', fast_length)
    macd_slow = EMA(df, 'close', slow_length)
    macd_diff = macd_fast - macd_slow
    t1 = (macd_diff - macd_diff.shift(1)) * sensitivity
    print("MACD and t1 calculated")  # Debug print

    # Calculate Bollinger Bands
    bb = BollingerBands(df, column='close', period=channel_length, std_dev=mult)
    e1 = bb['BB_upper'] - bb['BB_lower']
    print("Bollinger Bands calculated")  # Debug print

    trend_up = np.where(t1 >= 0, t1, 0)
    trend_down = np.where(t1 < 0, -t1, 0)

    df_copy['trend_up'] = trend_up.round(2)
    df_copy['trend_down'] = trend_down.round(2)
    df_copy['explosion_line'] = e1.round(2)
    df_copy['dead_zone_line'] = dead_zone.round(2)

    return df_copy[['trend_up', 'trend_down', 'explosion_line', 'dead_zone_line']]


def EWO(df, column="close", sma1_period=5, sma2_period=35):
    """
    Elliott Wave Oscillator (EWO)

    Call with:
        df['ewo'] = bta.EWO(df, "close", 5, 35)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EWO is to be calculated. Default is "close".
    - sma1_period (int): The period for the shorter SMA used in EWO calculation. Default is 5.
    - sma2_period (int): The period for the longer SMA used in EWO calculation. Default is 35.

    Returns:
    - pandas.Series: A series of EWO values.

    Description:
    The Elliott Wave Oscillator (EWO) is a specific tool to help you identify the trend and the overall market pattern to assist in finding future trading opportunities. It is derived by calculating the difference between a short and long period simple moving average, then normalizing the result with the close price.
    """
    sma1 = df[column].rolling(window=sma1_period).mean()
    sma2 = df[column].rolling(window=sma2_period).mean()
    ewo = (sma1 - sma2) / df[column] * 100

    return ewo


def MACD(df, column="close", short_window=12, long_window=26, signal_window=9):
    """
    Moving Average Convergence Divergence (MACD)

    Call with:
        macd_result = bta.MACD(df, "close", 12, 26, 9)
        df['macd'] = macd_result['MACD']
        df['macd_signal'] = macd_result['MACD_signal']
        df['macd_histogram'] = macd_result['MACD_histogram']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the "close" column.
    - short_window (int): The short-term period for EMA. Default is 12.
    - long_window (int): The long-term period for EMA. Default is 26.
    - signal_window (int): The signal line period for EMA. Default is 9.

    Returns:
    - pd.DataFrame: DataFrame with 'MACD', 'Signal', and 'Histogram' columns.

    Description:
    MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security’s price.
    """
    short_ema = EMA(df, column=column, period=short_window)
    long_ema = EMA(df, column=column, period=long_window)
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    histogram = macd - signal

    # Returning as DataFrame
    return pd.DataFrame({
        'MACD': macd,
        'MACD_signal': signal,
        'MACD_histogram': histogram
    })


def RSI(df, column="close", period=14):
    """
    Relative Strength Index (RSI)

    Call with:
        df['rsi'] = bta.RSI(df, "close", 14)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which RSI is to be calculated. Default is "close".
    - period (int): The period over which RSI is to be calculated. Default is 14.

    Returns:
    - pandas.Series: A series of RSI values.

    Description:
    RSI measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of a stock or other asset.
    """
    delta = df[column].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=period, min_periods=1).mean()
    avg_loss = loss.rolling(window=period, min_periods=1).mean()

    for i in range(period, len(df)):
        avg_gain[i] = (avg_gain[i-1] * (period - 1) + gain[i]) / period
        avg_loss[i] = (avg_loss[i-1] * (period - 1) + loss[i]) / period

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

        ----- End of momentum.py -----

        candles.py

        ----- Start of candles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import EMA


def HeikinAshi(df, pre_smoothing_period=None, post_smoothing_period=None):
    """
    Heikin Ashi (HA) with Optional Pre and Post Smoothing

    Call with:
    - Regular Heiken Ashi:
        ha_df = bta.HeikinAshi(df)

    - With pre-smoothing of the original data:
        ha_df = bta.HeikinAshi(df, pre_smoothing_period=14)

    - With both pre and post smoothing:
        ha_df = bta.HeikinAshi(df, pre_smoothing_period=14, post_smoothing_period=14)

    After calling, the following columns can be extracted:
        df['HA_Close'] = ha_df['HA_Close']
        df['HA_Open'] = ha_df['HA_Open']
        df['HA_High'] = ha_df['HA_High']
        df['HA_Low'] = ha_df['HA_Low']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - pre_smoothing_period (int, optional): Period for EMA pre-smoothing of the original data. If provided, original price bars are smoothed before Heikin Ashi calculations.
    - post_smoothing_period (int, optional): Period for EMA post-smoothing of Heikin Ashi values. If provided, Heikin Ashi values are smoothed post calculations.

    Returns:
    - pd.DataFrame: DataFrame with 'HA_Close', 'HA_Open', 'HA_High', 'HA_Low' columns.

    Description:
    Heikin Ashi is a type of price chart that shares some characteristics with candlestick charts but differs due to the values used to plot them. This modified version allows for optional smoothing of the original data before the Heikin Ashi calculation and/or smoothing of the Heikin Ashi values themselves, aiming to provide a more refined and smoother representation of price action, making it easier to identify the trend.
    """
    df_copy = df.copy()

    # If pre-smoothing is required
    if pre_smoothing_period:
        df_copy['open'] = EMA(df_copy, 'open', pre_smoothing_period)
        df_copy['close'] = EMA(df_copy, 'close', pre_smoothing_period)
        df_copy['high'] = EMA(df_copy, 'high', pre_smoothing_period)
        df_copy['low'] = EMA(df_copy, 'low', pre_smoothing_period)

    # Regular Heikin Ashi calculations
    df_copy['HA_Close'] = (df_copy['open'] + df_copy['high'] +
                           df_copy['low'] + df_copy['close']) / 4
    df_copy.reset_index(inplace=True)
    ha_open = [(df_copy['open'][0] + df_copy['close'][0]) / 2]
    [ha_open.append((ha_open[i] + df_copy['HA_Close'].values[i]) / 2)
     for i in range(0, len(df_copy) - 1)]
    df_copy['HA_Open'] = ha_open
    df_copy.set_index('index', inplace=True)
    df_copy['HA_High'] = df_copy[['HA_Open', 'HA_Close', 'high']].max(axis=1)
    df_copy['HA_Low'] = df_copy[['HA_Open', 'HA_Close', 'low']].min(axis=1)

    # If post-smoothing is required
    if post_smoothing_period:
        df_copy['HA_Open'] = EMA(df_copy, 'HA_Open', post_smoothing_period)
        df_copy['HA_High'] = EMA(df_copy, 'HA_High', post_smoothing_period)
        df_copy['HA_Low'] = EMA(df_copy, 'HA_Low', post_smoothing_period)
        df_copy['HA_Close'] = EMA(df_copy, 'HA_Close', post_smoothing_period)

    return df_copy[['HA_Open', 'HA_High', 'HA_Low', 'HA_Close']]


def LinRegCandles(df, linreg_length=11, sma_signal=True, signal_length=11):
    """
    Linear Regression Candles with Optional Signal Line

    Call with:
    - Regular Linear Regression Candles with SMA signal line:
        lr_df = bta.LinRegCandles(df)

    - With EMA signal line:
        lr_df = bta.LinRegCandles(df, sma_signal=False)

    - With SMA signal line:
        lr_df = bta.LinRegCandles(df, sma_signal=True)

    After calling, the following columns can be extracted:
        df['LRC_Open'] = lr_df['bopen']
        df['LRC_High'] = lr_df['bhigh']
        df['LRC_Low'] = lr_df['blow']
        df['LRC_Close'] = lr_df['bclose']
        df['LRC_Signal'] = lr_df['signal']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - linreg_length (int, optional): Period for linear regression calculation. Default is 11.
    - sma_signal (bool, optional): If True, uses SMA for the signal line. If False, uses EMA. Default is True.
    - signal_length (int, optional): Period for the moving average signal line. Default is 11.

    Returns:
    - pd.DataFrame: DataFrame with 'bopen', 'bhigh', 'blow', 'bclose' as the Linear Regression Candles, and 'signal' as the signal line.

    Description:
    The Linear Regression Candles transform the traditional OHLC bars using a linear regression algorithm, providing a smoothed representation of price action. The function also provides an optional signal line, which can be either an SMA or an EMA of the Linear Regression Candle close. This signal line can help to identify trends and potential trading signals.
    """
    df_copy = df.copy()

    # Calculate linear regression coefficients for open, high, low, and close
    df_copy['bopen'] = df_copy['open'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bhigh'] = df_copy['high'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['blow'] = df_copy['low'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bclose'] = df_copy['close'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    # Calculate the signal line using SMA or EMA
    if sma_signal:
        df_copy['signal'] = df_copy['bclose'].rolling(
            window=signal_length).mean()
    else:
        df_copy['signal'] = df_copy['bclose'].ewm(
            span=signal_length, adjust=False).mean()

    return df_copy

        ----- End of candles.py -----

        performance.py

        ----- Start of performance.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of performance.py -----

        trend.py

        ----- Start of trend.py -----

# -*- coding: utf-8 -*-
from pandas import DataFrame
import math
import numpy as np
import pandas as pd
# from .bamboo_ta import *
from .volatility import BollingerBands
# from .trend import SMA, EMA, LSMA, HMA, WMA


def AlligatorBands(df, column="close", jaw_period=13, teeth_period=8, lips_period=5, jaw_shift=8, teeth_shift=5, lips_shift=3):
    """
    Bill Williams Alligator Indicator

    Call with:
        alligator_result = bta.AlligatorBands(df, "high", 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
        df['jaw'] = alligator_result['jaw']
        df['teeth'] = alligator_result['teeth']
        df['lips'] = alligator_result['lips']

    Args:
    df (pd.DataFrame): DataFrame containing the data.
    column (str): The column name on which the Alligator is to be applied. Default is "close".
    jaw_period (int): Period for the Alligator's Jaw (blue line). Default is 13.
    teeth_period (int): Period for the Alligator's Teeth (red line). Default is 8.
    lips_period (int): Period for the Alligator's Lips (green line). Default is 5.
    jaw_shift (int): Number of periods to shift the Jaw line into the future. Default is 8.
    teeth_shift (int): Number of periods to shift the Teeth line into the future. Default is 5.
    lips_shift (int): Number of periods to shift the Lips line into the future. Default is 3.

    Returns:
    pd.DataFrame: DataFrame with 'jaw', 'teeth', and 'lips' columns added, optionally shifted into the future.
    """

    df['jaw'] = df[column].rolling(window=jaw_period).mean().shift(jaw_shift)
    df['teeth'] = df[column].rolling(
        window=teeth_period).mean().shift(teeth_shift)
    df['lips'] = df[column].rolling(
        window=lips_period).mean().shift(lips_shift)

    return df[['jaw', 'teeth', 'lips']]


def BollingerTrend(df, column="close", short_length=20, long_length=50, std_dev=2.0):
    """
    Bollinger Trend Indicator

    Call with:
        df['BBTrend'] = bta.BollingerTrend(df, "close", 20, 50, 2.0)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is "close".
    - short_length (int): The period for the short Bollinger Bands. Default is 20.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - stddev (float): The standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Returns:
    - pandas.Series: A series of BBTrend values.
    """
    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=std_dev)
    short_middle = short_bb['BB_middle']
    short_upper = short_bb['BB_upper']
    short_lower = short_bb['BB_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=std_dev)
    long_middle = long_bb['BB_middle']
    long_upper = long_bb['BB_upper']
    long_lower = long_bb['BB_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100
    bbtrend = bbtrend.round(2)
    
    return bbtrend


def BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14):
    """
    Bollinger Trend Indicator with selectable Moving Average

    This function calculates the Bollinger Trend (BBTrend) and applies a selected moving average to the BBTrend.

    Usage:
        BollingerTrendFast = bta.BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
        
        df['BollingerTrendFast'] = BollingerTrendFast['BBTrend']
        df['BollingerTrendFastMA'] = BollingerTrendFast['BBTrendMA']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is "close".
    - short_length (int): The period for the short Bollinger Bands. Default is 10.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - short_stddev (float): The standard deviation multiplier for the short Bollinger Bands. Default is 1.0.
    - long_stddev (float): The standard deviation multiplier for the long Bollinger Bands. Default is 2.0.
    - ma_type (str): The type of moving average to use ("SMA", "EMA", "LSMA", "HMA", "WMA"). Default is "SMA".
    - ma_length (int): The period for the moving average. Default is 14.

    Returns:
    - pandas.DataFrame: DataFrame with 'BBTrend' and 'MA' columns.
    
    Example:
        result = BollingerTrendWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
        df['BBTrend'] = result['BBTrend']
        df['MA'] = result['MA']
    """

    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=short_stddev)
    short_middle = short_bb['BB_middle']
    short_upper = short_bb['BB_upper']
    short_lower = short_bb['BB_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=long_stddev)
    long_middle = long_bb['BB_middle']
    long_upper = long_bb['BB_upper']
    long_lower = long_bb['BB_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100
    bbtrend = bbtrend.round(2)

    # Select and calculate the moving average
    if ma_type == "SMA":
        ma = SMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "EMA":
        ma = EMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "LSMA":
        ma = LSMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "HMA":
        ma = HMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "WMA":
        ma = WMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    else:
        raise ValueError("Unsupported moving average type")

    # Returning as DataFrame
    result = df.copy()
    result['BBTrend'] = bbtrend.round(2)
    result['BBTrendMA'] = ma.round(2)

    return result[['BBTrend', 'BBTrendMA']]


def EMA(df, column="close", period=21):
    """
    Exponential Moving Average (EMA)

    Call with:
        df['ema'] = bta.EMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EMA is to be calculated. Default is "close".
    - period (int): The period over which EMA is to be calculated. Default is 30.

    Returns:
    - pandas.Series: A series of EMA values.

    Description:
    The Exponential Moving Average gives more weight to recent prices and thus reacts more quickly to price changes than the Simple Moving Average.
    """

    ema = df[column].ewm(span=period, adjust=False).mean()
    
    return ema


def HMA(df, column="close", period=9):
    """
    Hull Moving Average (HMA)

    Call with:
        df['hma'] = bta.HMA(df, "close", 9)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which HMA is to be calculated. Default is "close".
    - period (int): The period over which HMA is to be calculated. Default is 9.

    Returns:
    - pandas.Series: A series of HMA values.

    Description:
    Hull Moving Average (HMA) is an improved moving average, responsive and with minimal lag. It involves the combination of WMA (Weighted Moving Average) with different periods.
    """

    # We're assuming that WMA is defined in the same file and thus is accessible here.
    half_length = math.floor(period / 2)
    sqrt_length = math.floor(math.sqrt(period))

    wma_half = WMA(df, column=column, period=half_length)
    wma_full = WMA(df, column=column, period=period)

    h = 2 * wma_half - wma_full
    h_df = DataFrame(h, columns=[column])
    hma = WMA(h_df, column=column, period=sqrt_length)

    return hma


def LSMA(df, column="close", period=21):
    """
    Least Squares Moving Average (LSMA)

    Call with:
        df['lsma'] = bta.LSMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which LSMA is to be calculated. Default is "close".
    - period (int): The period over which LSMA is to be calculated. Default is 21.

    Returns:
    - pandas.Series: A series of LSMA values.

    Description:
    LSMA uses linear regression to compute the trend of the data over a specified period. It fits a straight line to the data points using the method of least squares to depict the direction of movement.
    """
    lsma_values = []

    for i in range(period - 1, len(df)):
        # Extract the most recent N df points
        subset = df.iloc[i + 1 - period:i + 1]

        # Perform linear regression to fit a line
        x = np.arange(len(subset))
        y = subset[column].values
        slope, intercept = np.polyfit(x, y, 1)

        # Calculate the LSMA value using the linear equation
        lsma = intercept + slope * (period - 1)
        lsma_values.append(lsma)

    lsma = pd.Series(lsma_values, index=df.index[period - 1:])

    return lsma


def RMA(series, period):
    """
    Relative Moving Average (RMA) calculation.
    
    Parameters:
    - series (pandas.Series): Input series on which RMA is to be calculated.
    - period (int): The period over which RMA is to be calculated.
    
    Returns:
    - pandas.Series: A series of RMA values.
    """
    return series.ewm(alpha=1/period, adjust=False).mean()


def SMA(df, column="close", period=21):
    """
    Simple Moving Average (SMA)

    Call with:
        df['sma'] = bta.SMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which SMA is to be calculated. Default is "close".
    - period (int): The period over which SMA is to be calculated. Default is 30.

    Returns:
    - pandas.Series: A series of SMA values.

    Description:
    The Simple Moving Average is the unweighted mean of the previous 'period' data points.
    """

    sma = df[column].rolling(window=period).mean()
    
    return sma


def WMA(df, column="close", period=9):
    """
    TradingView-Style Weighted Moving Average (WMA)

    Call with:
        df['wma'] = bta.WMA(df, "close", 9)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which WMA is to be calculated. Default is "close".
    - period (int): The period over which WMA is to be calculated. Default is 9.

    Returns:
    - pandas.Series: A series of WMA values.

    Description:
    The Weighted Moving Average assigns weights linearly. The most recent data gets the highest weight.
    """
    weights = range(1, period + 1)
    numerator = df[column].rolling(window=period).apply(
        lambda x: sum(weights * x), raw=True)
    denominator = sum(weights)

    wma = numerator / denominator
    
    return wma


def ZLEMA(df, column="close", period=21):
    """
    Zero Lag Exponential Moving Average (ZLEMA)

    Call with:
        df['zlema'] = bta.ZLEMA(df, "close", 21)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which ZLEMA is to be calculated. Default is "close".
    - period (int): The period over which ZLEMA is to be calculated. Default is 21.

    Returns:
    - pandas.Series: A series of ZLEMA values.

    Description:
    Zero Lag Exponential Moving Average (ZLEMA) is an EMA that adjusts for lag, making it more responsive to recent price changes. It uses lagged data differences to adjust the EMA calculation, thereby supposedly removing the inherent lag of EMA.
    """
    lag = int((period - 1) / 2)

    # Calculating the adjusted data series
    ema_data = df[column] + (df[column] - df[column].shift(lag))

    # Computing the EMA of the adjusted data series
    zlema = ema_data.ewm(span=period, adjust=False).mean()

    return zlema



        ----- End of trend.py -----

        volatility.py

        ----- Start of volatility.py -----

# -*- coding: utf-8 -*-
# volatility.py
import numpy as np
import pandas as pd

def BollingerBands(df, column="close", period=20, std_dev=2, ddof=0):
    """
    Bollinger Bands (BBANDS)

    Call with:
        bb_result = bta.BollingerBands(df, "close", 21, 2, 0)
        df['bb_upper'] = bb_result['BB_upper']
        df['bb_middle'] = bb_result['BB_middle']
        df['bb_lower'] = bb_result['BB_lower']

    Args:
    df (pd.DataFrame): DataFrame containing the data
    column (str): The column name on which the BBANDS is to be applied
    period (int): Look-back period to compute the moving average
    std_dev (int): Number of standard deviations to compute the upper and lower bands
    ddof (int): Degrees of Freedom to use in standard deviation calculation. Default: 0

    Returns:
    pd.DataFrame: DataFrame with 'Upper_Band', 'Middle_Band', 'Lower_Band' columns added.
    """

    # Local import to avoid circular dependency
    from .trend import SMA

    # Middle Band = SMA
    sma = SMA(df, column=column, period=period)

    # Calculate standard deviation of the specified column
    rolling_std = df[column].rolling(window=period).std(ddof=ddof)

    # Upper Band = Middle Band + (std_dev * rolling standard deviation)
    upper_band = sma + (rolling_std * std_dev)

    # Lower Band = Middle Band - (std_dev * rolling standard deviation)
    lower_band = sma - (rolling_std * std_dev)

    # Returning as DataFrame
    return pd.DataFrame({
        'BB_upper': upper_band,
        'BB_middle': sma,
        'BB_lower': lower_band
    })


def TR(df):
    """
    True Range (TR) calculation.
    
    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'high', 'low', and 'close'.
    
    Returns:
    - pandas.Series: A series of True Range values.
    """
    high_low = df['high'] - df['low']
    high_close = np.abs(df['high'] - df['close'].shift())
    low_close = np.abs(df['low'] - df['close'].shift())

    tr = high_low.combine(high_close, max).combine(low_close, max)
    return tr
        ----- End of volatility.py -----

        bamboo_ta.py

        ----- Start of bamboo_ta.py -----

# bamboo_ta.py
# -*- coding: utf-8 -*-
# Import the individual bamboo ta libraries
from bamboo_ta.candles import *
from bamboo_ta.cycles import *
from bamboo_ta.momentum import *
from bamboo_ta.performance import *
from bamboo_ta.statistics import *
from bamboo_ta.trend import *
from bamboo_ta.utility import *
from bamboo_ta.volatility import *

        ----- End of bamboo_ta.py -----

        statistics.py

        ----- Start of statistics.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of statistics.py -----

        __init__.py

        ----- Start of __init__.py -----

# -*- coding: utf-8 -*-
from bamboo_ta.bamboo_ta import *
import numpy as np
from pandas import DataFrame
import pandas as pd

name = "bamboo_ta"
"""
.. moduleauthor:: DutchCryptoDad
"""

        ----- End of __init__.py -----


    ----- End of directory_structure.txt -----

    setup.py

    ----- Start of setup.py -----

from setuptools import setup, find_packages
import os

here = os.path.abspath(os.path.dirname(__file__))

VERSION = '0.0.5'
DESCRIPTION = 'TA library for Pandas'

with open("README.md", "r") as f:
    LONG_DESCRIPTION = f.read()

# Setting up
setup(
    name="bamboo-ta",
    version=VERSION,
    author="DutchCryptoDad (DCD)",
    author_email="<dutchcryptodad@gmail.com>",
    url="https://github.com/DutchCryptoDad/bamboo-ta",
    description=DESCRIPTION,
    long_description_content_type="text/markdown",
    long_description=LONG_DESCRIPTION,
    packages=find_packages(),
    keywords=['python', 'pandas', 'numpy',
              'trading', 'indicator', 'technical analysis'],
    classifiers=[
        "Development Status :: 1 - Planning",
        "Intended Audience :: Developers",
        "Programming Language :: Python :: 3",
        "Operating System :: Unix",
        "Operating System :: MacOS :: MacOS X",
        "Operating System :: Microsoft :: Windows",
    ],
    install_requires=['pandas', 'numpy'],
    extras_require={
        "def": ["pytest", "twine"],
    },
    python_requres=">=3.10",
)

    ----- End of setup.py -----

    requirements.txt

    ----- Start of requirements.txt -----

ta
numpy
pandas
pandas_ta

    ----- End of requirements.txt -----

    bamboo_ta/
        cycles.py

        ----- Start of cycles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of cycles.py -----

        volume.py

        ----- Start of volume.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import ema

def OBV_Oscillator(df, n1=10, n2=21):
    """
    On Balance Volume (OBV) Oscillator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'close' and 'volume'.
    - n1 (int): Length for the OBV EMA. Default is 10.
    - n2 (int): Length for the oscillator EMA. Default is 21.

    Call with:
        obv = OBV_Oscillator(df)
        df['obv_oscillator'] = obv['obv_oscillator']

    Returns:
    - pd.DataFrame: DataFrame with 'obv_oscillator' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    obv = np.where(df['close'].diff() > 0, df['volume'], 
                   np.where(df['close'].diff() < 0, -df['volume'], 0))
    obv = np.cumsum(obv)
    obv_ema_n1 = ema(pd.Series(obv), n1)
    oscillator = ema((obv - obv_ema_n1) / (0.015 * ema(np.abs(obv - obv_ema_n1), n1)), n2)

    df_copy['obv_oscillator'] = oscillator.round(2)
    
    return df_copy[['obv_oscillator']]
        ----- End of volume.py -----

        utility.py

        ----- Start of utility.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from bamboo_ta import OBV_Oscillator, MACD_Leader, QQE_Mod, CMO, Inverse_Fisher_Transform, WaveTrend_Oscillator

def pathways_to_profit(df):
    """
    Pathways to Profit Indicator Suite
    """
    df['OBV_Oscillator'] = OBV_Oscillator(df)['obv_oscillator']
    df['MACD_Leader'] = MACD_Leader(df, 'close')['macd_leader']
    qqe = QQE_Mod(df)
    df['QQE_RSI_MA'] = qqe['rsi_ma']
    df['QQE_Upper'] = qqe['upper']
    df['QQE_Lower'] = qqe['lower']
    df['CMO'] = CMO(df)['cmo']
    df['CMO_Signal'] = df['CMO'].rolling(window=10).mean()  # Using SMA for signal
    df['IFT'] = Inverse_Fisher_Transform(df)['ift']
    df['Wavetrend'] = WaveTrend_Oscillator(df, 'close')['wavetrend']

    return df
        ----- End of utility.py -----

        momentum.py

        ----- Start of momentum.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import *
from .volatility import *
# from .utility import *


def CMO(df, length=14):
    """
    Chande Momentum Oscillator (CMO)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - length (int): Length for the CMO calculation. Default is 14.

    Call with:
        cmo = CMO(df)
        df['cmo'] = cmo['cmo']

    Returns:
    - pd.DataFrame: DataFrame with 'cmo' column.
    """
    df_copy = df.copy()

    mom = df['close'].diff()
    pos_mom = mom.where(mom > 0, 0)
    neg_mom = -mom.where(mom < 0, 0)
    sm1 = pos_mom.rolling(window=length).sum()
    sm2 = neg_mom.rolling(window=length).sum()
    cmo = 100 * (sm1 - sm2) / (sm1 + sm2)

    df_copy['cmo'] = cmo.round(2)
    
    return df_copy[['cmo']]


def EWO(df, column="close", sma1_period=5, sma2_period=35):
    """
    Elliott Wave Oscillator (EWO)

    Call with:
        df['ewo'] = bta.EWO(df, "close", 5, 35)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EWO is to be calculated. Default is "close".
    - sma1_period (int): The period for the shorter SMA used in EWO calculation. Default is 5.
    - sma2_period (int): The period for the longer SMA used in EWO calculation. Default is 35.

    Returns:
    - pandas.Series: A series of EWO values.

    Description:
    The Elliott Wave Oscillator (EWO) is a specific tool to help you identify the trend and the overall market pattern to assist in finding future trading opportunities. It is derived by calculating the difference between a short and long period simple moving average, then normalizing the result with the close price.
    """
    sma1 = df[column].rolling(window=sma1_period).mean()
    sma2 = df[column].rolling(window=sma2_period).mean()
    ewo = (sma1 - sma2) / df[column] * 100

    return ewo


def MACD(df, column="close", short_window=12, long_window=26, signal_window=9):
    """
    Moving Average Convergence Divergence (MACD)

    Call with:
        macd_result = bta.MACD(df, "close", 12, 26, 9)
        df['macd'] = macd_result['MACD']
        df['macd_signal'] = macd_result['MACD_signal']
        df['macd_histogram'] = macd_result['MACD_histogram']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the "close" column.
    - short_window (int): The short-term period for EMA. Default is 12.
    - long_window (int): The long-term period for EMA. Default is 26.
    - signal_window (int): The signal line period for EMA. Default is 9.

    Returns:
    - pd.DataFrame: DataFrame with 'MACD', 'Signal', and 'Histogram' columns.

    Description:
    MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security’s price.
    """
    short_ema = EMA(df, column=column, period=short_window)
    long_ema = EMA(df, column=column, period=long_window)
    macd = short_ema - long_ema
    signal = macd.ewm(span=signal_window, adjust=False).mean()
    histogram = macd - signal

    # Returning as DataFrame
    return pd.DataFrame({
        'MACD': macd,
        'MACD_signal': signal,
        'MACD_histogram': histogram
    })


def MACD_Leader(df, src, fast_length=12, slow_length=26, signal_length=9):
    """
    MACD Leader

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the source column.
    - src (str): The column to use for calculations.
    - fast_length (int): Length for the fast EMA. Default is 12.
    - slow_length (int): Length for the slow EMA. Default is 26.
    - signal_length (int): Length for the signal EMA. Default is 9.

    Call with:
        macd_leader = MACD_Leader(df, 'close')
        df['macd_leader'] = macd_leader['macd_leader']

    Returns:
    - pd.DataFrame: DataFrame with 'macd_leader' column.
    """
    df_copy = df.copy()

    sema = EMA(df[src], fast_length)
    lema = EMA(df[src], slow_length)
    i1 = sema + EMA(df[src] - sema, fast_length)
    i2 = lema + EMA(df[src] - lema, slow_length)
    macd_leader = ((i1 - i2) / 10) * 100

    df_copy['macd_leader'] = macd_leader.round(2)
    
    return df_copy[['macd_leader']]


def Inverse_Fisher_Transform(df, rsi_length=14, wma_length=9):
    """
    Inverse Fisher Transform

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - rsi_length (int): Length for the RSI calculation. Default is 14.
    - wma_length (int): Length for the WMA calculation. Default is 9.

    Call with:
        ift = Inverse_Fisher_Transform(df)
        df['ift'] = ift['ift']

    Returns:
    - pd.DataFrame: DataFrame with 'ift' column.
    """
    df_copy = df.copy()

    v1 = 0.1 * (rsi(df['close'], rsi_length) - 50)
    v2 = v1.rolling(window=wma_length).mean()
    inv = ((np.exp(2 * v2) - 1) / (np.exp(2 * v2) + 1)) * 100

    df_copy['ift'] = inv.round(2)
    
    return df_copy[['ift']]


def Waddah_Attar_Explosion(df, sensitivity=150, fast_length=20, slow_length=40, channel_length=20, mult=2.0):
    """
    Waddah Attar Explosion Indicator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - sensitivity (int): Sensitivity factor for the indicator. Default is 150.
    - fast_length (int): Length for the fast EMA. Default is 20.
    - slow_length (int): Length for the slow EMA. Default is 40.
    - channel_length (int): Length for the Bollinger Bands. Default is 20.
    - mult (float): Standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Call with:
        WAE = bta.Waddah_Attar_Explosion(df)
        df['trend_up'] = WAE['trend_up']
        df['trend_down'] = WAE['trend_down']
        df['explosion_line'] = WAE['explosion_line']
        df['dead_zone_line'] = WAE['dead_zone_line']

    Returns:
    - pd.DataFrame: DataFrame with 'trend_up', 'trend_down', 'explosion_line', and 'dead_zone_line' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    print("DataFrame columns:", df.columns)  # Debug print
    print("First few rows of the DataFrame:\n", df.head())  # Debug print

    # Calculate DEAD_ZONE
    dead_zone = RMA(TR(df), 100) * 3.7
    print("DEAD_ZONE calculated")  # Debug print

    # Calculate MACD
    macd_fast = EMA(df, 'close', fast_length)
    macd_slow = EMA(df, 'close', slow_length)
    macd_diff = macd_fast - macd_slow
    t1 = (macd_diff - macd_diff.shift(1)) * sensitivity
    print("MACD and t1 calculated")  # Debug print

    # Calculate Bollinger Bands
    bb = BollingerBands(df, column='close', period=channel_length, std_dev=mult)
    e1 = bb['BB_upper'] - bb['BB_lower']
    print("Bollinger Bands calculated")  # Debug print

    trend_up = np.where(t1 >= 0, t1, 0)
    trend_down = np.where(t1 < 0, -t1, 0)

    df_copy['trend_up'] = trend_up.round(2)
    df_copy['trend_down'] = trend_down.round(2)
    df_copy['explosion_line'] = e1.round(2)
    df_copy['dead_zone_line'] = dead_zone.round(2)

    return df_copy[['trend_up', 'trend_down', 'explosion_line', 'dead_zone_line']]


def WaveTrend_Oscillator(df, src, n1=8, n2=12):
    """
    WaveTrend Oscillator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the source column.
    - src (str): The column to use for calculations.
    - n1 (int): Length for the first EMA. Default is 8.
    - n2 (int): Length for the second EMA. Default is 12.

    Call with:
        wt = WaveTrend_Oscillator(df, 'close')
        df['wavetrend'] = wt['wavetrend']

    Returns:
    - pd.DataFrame: DataFrame with 'wavetrend' column.
    """
    df_copy = df.copy()

    ema_src = EMA(df[src], n1)
    d = EMA(np.abs(df[src] - ema_src), n1)
    ci = (df[src] - ema_src) / (0.015 * d)
    tci = EMA(ci, n2)
    wavetrend = tci - SMA(tci, 4)

    df_copy['wavetrend'] = wavetrend.round(2)
    
    return df_copy[['wavetrend']]


def RSI(df, column="close", period=14):
    """
    Relative Strength Index (RSI)

    Call with:
        df['rsi'] = bta.RSI(df, "close", 14)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which RSI is to be calculated. Default is "close".
    - period (int): The period over which RSI is to be calculated. Default is 14.

    Returns:
    - pandas.Series: A series of RSI values.

    Description:
    RSI measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of a stock or other asset.
    """
    delta = df[column].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=period, min_periods=1).mean()
    avg_loss = loss.rolling(window=period, min_periods=1).mean()

    for i in range(period, len(df)):
        avg_gain[i] = (avg_gain[i-1] * (period - 1) + gain[i]) / period
        avg_loss[i] = (avg_loss[i-1] * (period - 1) + loss[i]) / period

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    return rsi


def QQE_Mod(df, rsi_period=6, sf=5, qqe_factor=3, thresh=3, length=50, mult=0.35):
    """
    QQE Mod Indicator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'close'.
    - rsi_period (int): Period for the RSI calculation. Default is 6.
    - sf (int): Smoothing factor for the RSI. Default is 5.
    - qqe_factor (float): QQE factor. Default is 3.
    - thresh (int): Threshold value. Default is 3.
    - length (int): Length for the Bollinger Bands. Default is 50.
    - mult (float): Multiplier for the Bollinger Bands. Default is 0.35.

    Call with:
        qqe = QQE_Mod(df)
        df['qqe_rsi_ma'] = qqe['rsi_ma']
        df['qqe_upper'] = qqe['upper']
        df['qqe_lower'] = qqe['lower']

    Returns:
    - pd.DataFrame: DataFrame with 'rsi_ma', 'upper', and 'lower' columns.
    """
    df_copy = df.copy()

    wilders_period = rsi_period * 2 - 1
    rsi_val = RSI(df['close'], rsi_period)
    rsi_ma = EMA(rsi_val, sf)
    atr_rsi = np.abs(rsi_ma.diff())
    ma_atr_rsi = EMA(atr_rsi, wilders_period)
    dar = EMA(ma_atr_rsi, wilders_period) * qqe_factor

    longband = np.zeros(len(df))
    shortband = np.zeros(len(df))
    trend = np.zeros(len(df))

    for i in range(1, len(df)):
        new_longband = rsi_ma[i] - dar[i]
        new_shortband = rsi_ma[i] + dar[i]
        longband[i] = max(longband[i - 1], new_longband) if rsi_ma[i - 1] > longband[i - 1] and rsi_ma[i] > longband[i - 1] else new_longband
        shortband[i] = min(shortband[i - 1], new_shortband) if rsi_ma[i - 1] < shortband[i - 1] and rsi_ma[i] < shortband[i - 1] else new_shortband
        trend[i] = 1 if rsi_ma[i] > shortband[i - 1] else -1 if rsi_ma[i] < longband[i - 1] else trend[i - 1]

    fast_atr_rsi_tl = np.where(trend == 1, longband, shortband)
    basis = SMA(fast_atr_rsi_tl - 50, length)
    dev = mult * stdev(fast_atr_rsi_tl - 50, length)
    upper = basis + dev
    lower = basis - dev

    df_copy['rsi_ma'] = rsi_ma.round(2)
    df_copy['upper'] = upper.round(2)
    df_copy['lower'] = lower.round(2)

    return df_copy[['rsi_ma', 'upper', 'lower']]
        ----- End of momentum.py -----

        candles.py

        ----- Start of candles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import EMA


def HeikinAshi(df, pre_smoothing_period=None, post_smoothing_period=None):
    """
    Heikin Ashi (HA) with Optional Pre and Post Smoothing

    Call with:
    - Regular Heiken Ashi:
        ha_df = bta.HeikinAshi(df)

    - With pre-smoothing of the original data:
        ha_df = bta.HeikinAshi(df, pre_smoothing_period=14)

    - With both pre and post smoothing:
        ha_df = bta.HeikinAshi(df, pre_smoothing_period=14, post_smoothing_period=14)

    After calling, the following columns can be extracted:
        df['HA_Close'] = ha_df['HA_Close']
        df['HA_Open'] = ha_df['HA_Open']
        df['HA_High'] = ha_df['HA_High']
        df['HA_Low'] = ha_df['HA_Low']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - pre_smoothing_period (int, optional): Period for EMA pre-smoothing of the original data. If provided, original price bars are smoothed before Heikin Ashi calculations.
    - post_smoothing_period (int, optional): Period for EMA post-smoothing of Heikin Ashi values. If provided, Heikin Ashi values are smoothed post calculations.

    Returns:
    - pd.DataFrame: DataFrame with 'HA_Close', 'HA_Open', 'HA_High', 'HA_Low' columns.

    Description:
    Heikin Ashi is a type of price chart that shares some characteristics with candlestick charts but differs due to the values used to plot them. This modified version allows for optional smoothing of the original data before the Heikin Ashi calculation and/or smoothing of the Heikin Ashi values themselves, aiming to provide a more refined and smoother representation of price action, making it easier to identify the trend.
    """
    df_copy = df.copy()

    # If pre-smoothing is required
    if pre_smoothing_period:
        df_copy['open'] = EMA(df_copy, 'open', pre_smoothing_period)
        df_copy['close'] = EMA(df_copy, 'close', pre_smoothing_period)
        df_copy['high'] = EMA(df_copy, 'high', pre_smoothing_period)
        df_copy['low'] = EMA(df_copy, 'low', pre_smoothing_period)

    # Regular Heikin Ashi calculations
    df_copy['HA_Close'] = (df_copy['open'] + df_copy['high'] +
                           df_copy['low'] + df_copy['close']) / 4
    df_copy.reset_index(inplace=True)
    ha_open = [(df_copy['open'][0] + df_copy['close'][0]) / 2]
    [ha_open.append((ha_open[i] + df_copy['HA_Close'].values[i]) / 2)
     for i in range(0, len(df_copy) - 1)]
    df_copy['HA_Open'] = ha_open
    df_copy.set_index('index', inplace=True)
    df_copy['HA_High'] = df_copy[['HA_Open', 'HA_Close', 'high']].max(axis=1)
    df_copy['HA_Low'] = df_copy[['HA_Open', 'HA_Close', 'low']].min(axis=1)

    # If post-smoothing is required
    if post_smoothing_period:
        df_copy['HA_Open'] = EMA(df_copy, 'HA_Open', post_smoothing_period)
        df_copy['HA_High'] = EMA(df_copy, 'HA_High', post_smoothing_period)
        df_copy['HA_Low'] = EMA(df_copy, 'HA_Low', post_smoothing_period)
        df_copy['HA_Close'] = EMA(df_copy, 'HA_Close', post_smoothing_period)

    return df_copy[['HA_Open', 'HA_High', 'HA_Low', 'HA_Close']]


def LinRegCandles(df, linreg_length=11, sma_signal=True, signal_length=11):
    """
    Linear Regression Candles with Optional Signal Line

    Call with:
    - Regular Linear Regression Candles with SMA signal line:
        lr_df = bta.LinRegCandles(df)

    - With EMA signal line:
        lr_df = bta.LinRegCandles(df, sma_signal=False)

    - With SMA signal line:
        lr_df = bta.LinRegCandles(df, sma_signal=True)

    After calling, the following columns can be extracted:
        df['LRC_Open'] = lr_df['bopen']
        df['LRC_High'] = lr_df['bhigh']
        df['LRC_Low'] = lr_df['blow']
        df['LRC_Close'] = lr_df['bclose']
        df['LRC_Signal'] = lr_df['signal']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - linreg_length (int, optional): Period for linear regression calculation. Default is 11.
    - sma_signal (bool, optional): If True, uses SMA for the signal line. If False, uses EMA. Default is True.
    - signal_length (int, optional): Period for the moving average signal line. Default is 11.

    Returns:
    - pd.DataFrame: DataFrame with 'bopen', 'bhigh', 'blow', 'bclose' as the Linear Regression Candles, and 'signal' as the signal line.

    Description:
    The Linear Regression Candles transform the traditional OHLC bars using a linear regression algorithm, providing a smoothed representation of price action. The function also provides an optional signal line, which can be either an SMA or an EMA of the Linear Regression Candle close. This signal line can help to identify trends and potential trading signals.
    """
    df_copy = df.copy()

    # Calculate linear regression coefficients for open, high, low, and close
    df_copy['bopen'] = df_copy['open'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bhigh'] = df_copy['high'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['blow'] = df_copy['low'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bclose'] = df_copy['close'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[
            1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    # Calculate the signal line using SMA or EMA
    if sma_signal:
        df_copy['signal'] = df_copy['bclose'].rolling(
            window=signal_length).mean()
    else:
        df_copy['signal'] = df_copy['bclose'].ewm(
            span=signal_length, adjust=False).mean()

    return df_copy

        ----- End of candles.py -----

        performance.py

        ----- Start of performance.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of performance.py -----

        trend.py

        ----- Start of trend.py -----

# -*- coding: utf-8 -*-
from pandas import DataFrame
import math
import numpy as np
import pandas as pd
# from .bamboo_ta import *
from .volatility import BollingerBands
# from .trend import SMA, EMA, LSMA, HMA, WMA


def AlligatorBands(df, column="close", jaw_period=13, teeth_period=8, lips_period=5, jaw_shift=8, teeth_shift=5, lips_shift=3):
    """
    Bill Williams Alligator Indicator

    Call with:
        alligator_result = bta.AlligatorBands(df, "high", 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
        df['jaw'] = alligator_result['jaw']
        df['teeth'] = alligator_result['teeth']
        df['lips'] = alligator_result['lips']

    Args:
    df (pd.DataFrame): DataFrame containing the data.
    column (str): The column name on which the Alligator is to be applied. Default is "close".
    jaw_period (int): Period for the Alligator's Jaw (blue line). Default is 13.
    teeth_period (int): Period for the Alligator's Teeth (red line). Default is 8.
    lips_period (int): Period for the Alligator's Lips (green line). Default is 5.
    jaw_shift (int): Number of periods to shift the Jaw line into the future. Default is 8.
    teeth_shift (int): Number of periods to shift the Teeth line into the future. Default is 5.
    lips_shift (int): Number of periods to shift the Lips line into the future. Default is 3.

    Returns:
    pd.DataFrame: DataFrame with 'jaw', 'teeth', and 'lips' columns added, optionally shifted into the future.
    """

    df['jaw'] = df[column].rolling(window=jaw_period).mean().shift(jaw_shift)
    df['teeth'] = df[column].rolling(
        window=teeth_period).mean().shift(teeth_shift)
    df['lips'] = df[column].rolling(
        window=lips_period).mean().shift(lips_shift)

    return df[['jaw', 'teeth', 'lips']]


def BollingerTrend(df, column="close", short_length=20, long_length=50, std_dev=2.0):
    """
    Bollinger Trend Indicator

    Call with:
        df['BBTrend'] = bta.BollingerTrend(df, "close", 20, 50, 2.0)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is "close".
    - short_length (int): The period for the short Bollinger Bands. Default is 20.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - stddev (float): The standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Returns:
    - pandas.Series: A series of BBTrend values.
    """
    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=std_dev)
    short_middle = short_bb['BB_middle']
    short_upper = short_bb['BB_upper']
    short_lower = short_bb['BB_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=std_dev)
    long_middle = long_bb['BB_middle']
    long_upper = long_bb['BB_upper']
    long_lower = long_bb['BB_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100
    bbtrend = bbtrend.round(2)
    
    return bbtrend


def BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14):
    """
    Bollinger Trend Indicator with selectable Moving Average

    This function calculates the Bollinger Trend (BBTrend) and applies a selected moving average to the BBTrend.

    Usage:
        BollingerTrendFast = bta.BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
        
        df['BollingerTrendFast'] = BollingerTrendFast['BBTrend']
        df['BollingerTrendFastMA'] = BollingerTrendFast['BBTrendMA']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is "close".
    - short_length (int): The period for the short Bollinger Bands. Default is 10.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - short_stddev (float): The standard deviation multiplier for the short Bollinger Bands. Default is 1.0.
    - long_stddev (float): The standard deviation multiplier for the long Bollinger Bands. Default is 2.0.
    - ma_type (str): The type of moving average to use ("SMA", "EMA", "LSMA", "HMA", "WMA"). Default is "SMA".
    - ma_length (int): The period for the moving average. Default is 14.

    Returns:
    - pandas.DataFrame: DataFrame with 'BBTrend' and 'MA' columns.
    
    Example:
        result = BollingerTrendWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
        df['BBTrend'] = result['BBTrend']
        df['MA'] = result['MA']
    """

    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=short_stddev)
    short_middle = short_bb['BB_middle']
    short_upper = short_bb['BB_upper']
    short_lower = short_bb['BB_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=long_stddev)
    long_middle = long_bb['BB_middle']
    long_upper = long_bb['BB_upper']
    long_lower = long_bb['BB_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100
    bbtrend = bbtrend.round(2)

    # Select and calculate the moving average
    if ma_type == "SMA":
        ma = SMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "EMA":
        ma = EMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "LSMA":
        ma = LSMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "HMA":
        ma = HMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    elif ma_type == "WMA":
        ma = WMA(df.assign(BBTrend=bbtrend), column="BBTrend", period=ma_length)
    else:
        raise ValueError("Unsupported moving average type")

    # Returning as DataFrame
    result = df.copy()
    result['BBTrend'] = bbtrend.round(2)
    result['BBTrendMA'] = ma.round(2)

    return result[['BBTrend', 'BBTrendMA']]


def EMA(df, column="close", period=21):
    """
    Exponential Moving Average (EMA)

    Call with:
        df['ema'] = bta.EMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EMA is to be calculated. Default is "close".
    - period (int): The period over which EMA is to be calculated. Default is 30.

    Returns:
    - pandas.Series: A series of EMA values.

    Description:
    The Exponential Moving Average gives more weight to recent prices and thus reacts more quickly to price changes than the Simple Moving Average.
    """

    ema = df[column].ewm(span=period, adjust=False).mean()
    
    return ema


def HMA(df, column="close", period=9):
    """
    Hull Moving Average (HMA)

    Call with:
        df['hma'] = bta.HMA(df, "close", 9)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which HMA is to be calculated. Default is "close".
    - period (int): The period over which HMA is to be calculated. Default is 9.

    Returns:
    - pandas.Series: A series of HMA values.

    Description:
    Hull Moving Average (HMA) is an improved moving average, responsive and with minimal lag. It involves the combination of WMA (Weighted Moving Average) with different periods.
    """

    # We're assuming that WMA is defined in the same file and thus is accessible here.
    half_length = math.floor(period / 2)
    sqrt_length = math.floor(math.sqrt(period))

    wma_half = WMA(df, column=column, period=half_length)
    wma_full = WMA(df, column=column, period=period)

    h = 2 * wma_half - wma_full
    h_df = DataFrame(h, columns=[column])
    hma = WMA(h_df, column=column, period=sqrt_length)

    return hma


def LSMA(df, column="close", period=21):
    """
    Least Squares Moving Average (LSMA)

    Call with:
        df['lsma'] = bta.LSMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which LSMA is to be calculated. Default is "close".
    - period (int): The period over which LSMA is to be calculated. Default is 21.

    Returns:
    - pandas.Series: A series of LSMA values.

    Description:
    LSMA uses linear regression to compute the trend of the data over a specified period. It fits a straight line to the data points using the method of least squares to depict the direction of movement.
    """
    lsma_values = []

    for i in range(period - 1, len(df)):
        # Extract the most recent N df points
        subset = df.iloc[i + 1 - period:i + 1]

        # Perform linear regression to fit a line
        x = np.arange(len(subset))
        y = subset[column].values
        slope, intercept = np.polyfit(x, y, 1)

        # Calculate the LSMA value using the linear equation
        lsma = intercept + slope * (period - 1)
        lsma_values.append(lsma)

    lsma = pd.Series(lsma_values, index=df.index[period - 1:])

    return lsma


def RMA(series, period):
    """
    Relative Moving Average (RMA) calculation.
    
    Parameters:
    - series (pandas.Series): Input series on which RMA is to be calculated.
    - period (int): The period over which RMA is to be calculated.
    
    Returns:
    - pandas.Series: A series of RMA values.
    """
    return series.ewm(alpha=1/period, adjust=False).mean()


def SMA(df, column="close", period=21):
    """
    Simple Moving Average (SMA)

    Call with:
        df['sma'] = bta.SMA(df, "close", 50)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which SMA is to be calculated. Default is "close".
    - period (int): The period over which SMA is to be calculated. Default is 30.

    Returns:
    - pandas.Series: A series of SMA values.

    Description:
    The Simple Moving Average is the unweighted mean of the previous 'period' data points.
    """

    sma = df[column].rolling(window=period).mean()
    
    return sma


def stdev(series, period):
    """
    Calculate the standard deviation over a specified period.

    Parameters:
    - series (pd.Series): The data series to calculate the standard deviation for.
    - period (int): The period over which to calculate the standard deviation.

    Returns:
    - pd.Series: The standard deviation of the series.
    """
    return series.rolling(window=period).std()


def WMA(df, column="close", period=9):
    """
    TradingView-Style Weighted Moving Average (WMA)

    Call with:
        df['wma'] = bta.WMA(df, "close", 9)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which WMA is to be calculated. Default is "close".
    - period (int): The period over which WMA is to be calculated. Default is 9.

    Returns:
    - pandas.Series: A series of WMA values.

    Description:
    The Weighted Moving Average assigns weights linearly. The most recent data gets the highest weight.
    """
    weights = range(1, period + 1)
    numerator = df[column].rolling(window=period).apply(
        lambda x: sum(weights * x), raw=True)
    denominator = sum(weights)

    wma = numerator / denominator
    
    return wma


def ZLEMA(df, column="close", period=21):
    """
    Zero Lag Exponential Moving Average (ZLEMA)

    Call with:
        df['zlema'] = bta.ZLEMA(df, "close", 21)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which ZLEMA is to be calculated. Default is "close".
    - period (int): The period over which ZLEMA is to be calculated. Default is 21.

    Returns:
    - pandas.Series: A series of ZLEMA values.

    Description:
    Zero Lag Exponential Moving Average (ZLEMA) is an EMA that adjusts for lag, making it more responsive to recent price changes. It uses lagged data differences to adjust the EMA calculation, thereby supposedly removing the inherent lag of EMA.
    """
    lag = int((period - 1) / 2)

    # Calculating the adjusted data series
    ema_data = df[column] + (df[column] - df[column].shift(lag))

    # Computing the EMA of the adjusted data series
    zlema = ema_data.ewm(span=period, adjust=False).mean()

    return zlema



        ----- End of trend.py -----

        volatility.py

        ----- Start of volatility.py -----

# -*- coding: utf-8 -*-
# volatility.py
import numpy as np
import pandas as pd

def BollingerBands(df, column="close", period=20, std_dev=2, ddof=0):
    """
    Bollinger Bands (BBANDS)

    Call with:
        bb_result = bta.BollingerBands(df, "close", 21, 2, 0)
        df['bb_upper'] = bb_result['BB_upper']
        df['bb_middle'] = bb_result['BB_middle']
        df['bb_lower'] = bb_result['BB_lower']

    Args:
    df (pd.DataFrame): DataFrame containing the data
    column (str): The column name on which the BBANDS is to be applied
    period (int): Look-back period to compute the moving average
    std_dev (int): Number of standard deviations to compute the upper and lower bands
    ddof (int): Degrees of Freedom to use in standard deviation calculation. Default: 0

    Returns:
    pd.DataFrame: DataFrame with 'Upper_Band', 'Middle_Band', 'Lower_Band' columns added.
    """

    # Local import to avoid circular dependency
    from .trend import SMA

    # Middle Band = SMA
    sma = SMA(df, column=column, period=period)

    # Calculate standard deviation of the specified column
    rolling_std = df[column].rolling(window=period).std(ddof=ddof)

    # Upper Band = Middle Band + (std_dev * rolling standard deviation)
    upper_band = sma + (rolling_std * std_dev)

    # Lower Band = Middle Band - (std_dev * rolling standard deviation)
    lower_band = sma - (rolling_std * std_dev)

    # Returning as DataFrame
    return pd.DataFrame({
        'BB_upper': upper_band,
        'BB_middle': sma,
        'BB_lower': lower_band
    })


def TR(df):
    """
    True Range (TR) calculation.
    
    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'high', 'low', and 'close'.
    
    Returns:
    - pandas.Series: A series of True Range values.
    """
    high_low = df['high'] - df['low']
    high_close = np.abs(df['high'] - df['close'].shift())
    low_close = np.abs(df['low'] - df['close'].shift())

    tr = high_low.combine(high_close, max).combine(low_close, max)
    return tr
        ----- End of volatility.py -----

        bamboo_ta.py

        ----- Start of bamboo_ta.py -----

# bamboo_ta.py
# -*- coding: utf-8 -*-
# Import the individual bamboo ta libraries
from bamboo_ta.candles import *
from bamboo_ta.cycles import *
from bamboo_ta.momentum import *
from bamboo_ta.performance import *
from bamboo_ta.statistics import *
from bamboo_ta.trend import *
from bamboo_ta.utility import *
from bamboo_ta.volatility import *

        ----- End of bamboo_ta.py -----

        statistics.py

        ----- Start of statistics.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of statistics.py -----

        __init__.py

        ----- Start of __init__.py -----

# -*- coding: utf-8 -*-
from bamboo_ta.bamboo_ta import *
import numpy as np
from pandas import DataFrame
import pandas as pd

name = "bamboo_ta"
"""
.. moduleauthor:: DutchCryptoDad
"""

        ----- End of __init__.py -----

