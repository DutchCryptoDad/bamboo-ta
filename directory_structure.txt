## Project Structure
The project is organized into the following directories:
```
./
│   ├── .vscode/
│   ├── bamboo_ta/
│   ├── docs/
│   └── prompts.md
│   └── requirements.txt
│   └── setup.py
│   ├── .vscode/
│   │   └── settings.json
│   ├── bamboo_ta/
│   │   └── bamboo_ta.py
│   │   └── candles.py
│   │   └── cycles.py
│   │   └── momentum.py
│   │   └── performance.py
│   │   └── statistics.py
│   │   └── trend.py
│   │   └── utility.py
│   │   └── volatility.py
│   │   └── volume.py
│   │   └── __init__.py
│   ├── docs/
│   │   └── candles.md
│   │   └── cycles.md
│   │   └── momentum.md
│   │   └── performance.md
│   │   └── statistics.md
│   │   └── trend.md
│   │   └── utility.md
│   │   └── volatility.md
│   │   └── volume.md
```

Detailed File Contents:

./
    prompts.md

    ----- Start of prompts.md -----

GPT Prompt:
1. You are a developer with extensive knowledge of Python and Pinescript. You have this project where you are converting Pinscripts into Python functions so that you can use these in a library for further data analysis in python. The project structure and code of the Python code will follow. After that wait for further instructions about the pinescript to convert. Is that understood?

2. The following pinsecript should be converted into a python function. If this pinescript is depending on other indicators from other libraries (e.g. pandas-ta), do not use that, but instead create additional functions that will take care of the missing indicators. If the indicators are already available in the given project, then use these indicators. Is this clear?

3. Further instructions based on output GPT.

GPT prompt

1. You are a developer with extensive knowledge of Python and Technical Indicators in Trading. You enherited a project where trading technical analsis indicators are programmed in a TA library with Python functions. However you noticed that the previous programmer was very inconsistent in its programming and functions are build in different ways. Your task is to refactor the code so that all the functions have the same building style, input method, calculation method and output method. Also watch for redundant code and if detected solve this too by pointing to the correct funtion.
The project structure and code of the Python code will follow next. After that wait for further instructions about the definitive way each function should be build for consistency.
Is that understood?

2. The code should be refactored into the same format style as previously mentioned. 
Please be extra aware of the naming convention of the functions, the way the descriptions are written, including the "call with:" example and the way the output is provided by means of the df_copy method and all the dataframe column names should be in lowercase, and keep the output limited to two decimals behind the comma or .. 
Please use the same function style and buildup, inputs and output style, example in the description like "call with" and more from the next example I will provide you next. So format to match the desired style and including a brief description of the indicator's purpose and functionality, with lowercase column names and limiting the output to two decimal places, ensure consistency in how single-column indicators are handled. After this prompt I will provide you with the different modules that have to be refactored.
Is this clear?

3. Here is the example function:

def Waddah_Attar_Explosion(df, sensitivity=150, fast_length=20, slow_length=40, channel_length=20, mult=2.0):
   '''
    Waddah Attar Explosion Indicator

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - sensitivity (int): Sensitivity factor for the indicator. Default is 150.
    - fast_length (int): Length for the fast EMA. Default is 20.
    - slow_length (int): Length for the slow EMA. Default is 40.
    - channel_length (int): Length for the Bollinger Bands. Default is 20.
    - mult (float): Standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Call with:
        WAE = bta.Waddah_Attar_Explosion(df)
        df['trend_up'] = WAE['trend_up']
        df['trend_down'] = WAE['trend_down']
        df['explosion_line'] = WAE['explosion_line']
        df['dead_zone_line'] = WAE['dead_zone_line']

    Returns:
    - pd.DataFrame: DataFrame with 'trend_up', 'trend_down', 'explosion_line', and 'dead_zone_line' columns.
    '''
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # print("DataFrame columns:", df.columns)  # Debug print
    # print("First few rows of the DataFrame:\n", df.head())  # Debug print

    # Calculate DEAD_ZONE
    dead_zone = RMA(TR(df), 100) * 3.7
    # print("DEAD_ZONE calculated")  # Debug print

    # Calculate MACD
    macd_fast = EMA(df, 'close', fast_length)
    macd_slow = EMA(df, 'close', slow_length)
    macd_diff = macd_fast - macd_slow
    t1 = (macd_diff - macd_diff.shift(1)) * sensitivity
    # print("MACD and t1 calculated")  # Debug print

    # Calculate Bollinger Bands
    bb = BollingerBands(df, column='close', period=channel_length, std_dev=mult)
    e1 = bb['BB_upper'] - bb['BB_lower']
    # print("Bollinger Bands calculated")  # Debug print

    trend_up = np.where(t1 >= 0, t1, 0)
    trend_down = np.where(t1 < 0, -t1, 0)

    df_copy['trend_up'] = trend_up.round(2)
    df_copy['trend_down'] = trend_down.round(2)
    df_copy['explosion_line'] = e1.round(2)
    df_copy['dead_zone_line'] = dead_zone.round(2)

    return df_copy[['trend_up', 'trend_down', 'explosion_line', 'dead_zone_line']]


GPT Prompt:
1. You are a developer with extensive knowledge of Python and Technical Indicators in Trading. You have this project where you are converting Third party Python code into your own TA library with Python functions so that you can use these within your own library in a consequent and familiar way for further data analysis in python. The project structure and code of the Python code will follow. After that wait for further instructions about the third party Python code to convert. Is that understood?

2. The following third party python should be converted into the same format as my own functions  and should also be added to their consequitive modules. Please check first if they already exist, if they do, then ignore these (but say that you will not create these). If the third party Python code is depending on other libraries (e.g. pandas-ta), do not use these external libraries, but instead create additional functions that will take care of the missing functions or indicators. If these dependend functions alreaty exist in your own project, then use those instead. Please be extra aware of the naming convention of these functions, the way the descriptions are written, including the "call with:" example and the way the output is provided by means of the df_copy method. 

3. Further instructions based on output GPT.


GPT Prompt:
1. I have a Readme file that is part of a complete python programm. It contains the descriptions of functions that are in the submoduled. However I have added more functions to these modules and I would like to recreate this Readme section so that it also contains the added funtions. In other words the Readme file is updated with the most current situation. 

I can give you the current modules Readme section now and later the complete contents of all other modules so that you can update the Readme section with this. Do you understand?


1. I now have a competely different question concerning the Readme file I have for this modules library. Can you help me with this too?


2. The original Readme file looks like this, but it now misses a lot of new functions we added to the different modules. Please rewrite this section with the information I give you in the next prompt. There you should extract the functions from the modules and add these to the Readme section in the same original style. Do you understand?

This is the original Readme section:

3. Further instructions based on output GPT.

ChatGPT prompt for refactoring:





[python] Here is an overview of the instructions used to refactor the code, ensuring consistency and clarity across all functions:

### Instructions for Refactoring the Code:

1. **Function Name and Description**:
   - Follow PEP-8 naming conventions.
   - Include a descriptive docstring detailing the function's purpose, parameters, usage example, and return values.
   - Start the docstring with a brief description of the indicator's purpose and functionality.

2. **Parameters**:
   - Clearly define parameters with default values where appropriate.
   - Explain each parameter in the docstring, including the data type and purpose.

3. **Input Validation**:
   - Ensure the input DataFrame contains the required columns.
   - Raise a `KeyError` if any required columns are missing.

4. **Calculations**:
   - Perform calculations step-by-step, with clear comments if necessary.
   - Use appropriate methods for moving averages (e.g., rolling mean for SMA, exponential weighted mean for EMA).

5. **Output**:
   - Return a DataFrame containing the new indicator columns.
   - Ensure all DataFrame column names are in lowercase.
   - Limit the output values to two decimal places using `.round(2)`.

6. **Example Calls**:
   - Include example calls in the docstring, showing how to use the function.
   - Demonstrate how to add the new columns to the original DataFrame.

### Example of a Refactored Function:

#### Heikin Ashi (HA) with Optional Pre and Post Smoothing:

```python
def heikin_ashi(df, pre_smoothing_period=None, post_smoothing_period=None):
    """
    Heikin Ashi (HA) with Optional Pre and Post Smoothing

    Heikin Ashi is a type of price chart that shares some characteristics with candlestick charts but differs due to the values used to plot them. 
    This modified version allows for optional smoothing of the original data before the Heikin Ashi calculation and/or smoothing of the Heikin Ashi values themselves, 
    aiming to provide a more refined and smoother representation of price action, making it easier to identify the trend.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - pre_smoothing_period (int, optional): Period for EMA pre-smoothing of the original data. If provided, original price bars are smoothed before Heikin Ashi calculations.
    - post_smoothing_period (int, optional): Period for EMA post-smoothing of Heikin Ashi values. If provided, Heikin Ashi values are smoothed post calculations.

    Call with:
        ha_df = bta.heikin_ashi(df)
        df['ha_close'] = ha_df['ha_close']
        df['ha_open'] = ha_df['ha_open']
        df['ha_high'] = ha_df['ha_high']
        df['ha_low'] = ha_df['ha_low']

    Returns:
    - pd.DataFrame: DataFrame with 'ha_open', 'ha_high', 'ha_low', and 'ha_close' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # If pre-smoothing is required
    if pre_smoothing_period:
        df_copy['open'] = ema(df_copy, 'open', pre_smoothing_period)
        df_copy['close'] = ema(df_copy, 'close', pre_smoothing_period)
        df_copy['high'] = ema(df_copy, 'high', pre_smoothing_period)
        df_copy['low'] = ema(df_copy, 'low', pre_smoothing_period)

    # Regular Heikin Ashi calculations
    df_copy['ha_close'] = (df_copy['open'] + df_copy['high'] +
                           df_copy['low'] + df_copy['close']) / 4
    df_copy.reset_index(inplace=True)
    ha_open = [(df_copy['open'][0] + df_copy['close'][0]) / 2]
    [ha_open.append((ha_open[i] + df_copy['ha_close'].values[i]) / 2)
     for i in range(0, len(df_copy) - 1)]
    df_copy['ha_open'] = ha_open
    df_copy.set_index('index', inplace=True)
    df_copy['ha_high'] = df_copy[['ha_open', 'ha_close', 'high']].max(axis=1)
    df_copy['ha_low'] = df_copy[['ha_open', 'ha_close', 'low']].min(axis=1)

    # If post-smoothing is required
    if post_smoothing_period:
        df_copy['ha_open'] = ema(df_copy, 'ha_open', post_smoothing_period)
        df_copy['ha_high'] = ema(df_copy, 'ha_high', post_smoothing_period)
        df_copy['ha_low'] = ema(df_copy, 'ha_low', post_smoothing_period)
        df_copy['ha_close'] = ema(df_copy, 'ha_close', post_smoothing_period)

    # Limit to two decimal places
    df_copy['ha_open'] = df_copy['ha_open'].round(2)
    df_copy['ha_high'] = df_copy['ha_high'].round(2)
    df_copy['ha_low'] = df_copy['ha_low'].round(2)
    df_copy['ha_close'] = df_copy['ha_close'].round(2)

    return df_copy[['ha_open', 'ha_high', 'ha_low', 'ha_close']]
```

#### Awesome Oscillator (AO):

```python
def awesome_oscillator(df, window1=5, window2=34, fillna=False):
    """
    Awesome Oscillator (AO)

    The Awesome Oscillator is a momentum indicator used to measure market momentum.
    It is calculated by subtracting a 34-period simple moving average (SMA) of the
    median price from a 5-period SMA of the median price.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'high' and 'low'.
    - window1 (int, optional): Short period. Default is 5.
    - window2 (int, optional): Long period. Default is 34.
    - fillna (bool, optional): If True, fill nan values with 0. Default is False.

    Call with:
        df['ao'] = bta.awesome_oscillator(df)

    Returns:
    - pd.DataFrame: DataFrame with 'ao' column.
    """
    df_copy = df.copy()

    median_price = 0.5 * (df['high'] + df['low'])
    min_periods_s = 0 if fillna else window1
    min_periods_l = 0 if fillna else window2
    df_copy['ao'] = (
        median_price.rolling(window1, min_periods=min_periods_s).mean()
        - median_price.rolling(window2, min_periods=min_periods_l).mean()
    )
    if fillna:
        df_copy['ao'] = df_copy['ao'].fillna(0)

    df_copy['ao'] = df_copy['ao'].round(2)
    return df_copy[['ao']]
```

#### Chande Momentum Oscillator (CMO):

```python
def chande_momentum_oscillator(df, length=14):
    """
    Chande Momentum Oscillator (CMO)

    The Chande Momentum Oscillator (CMO) is a technical momentum indicator developed by Tushar Chande. 
    It measures the amount that an asset's price has changed over a specified period of time.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - length (int): Length for the CMO calculation. Default is 14.

    Call with:
        df['cmo'] = bta.chande_momentum_oscillator(df)

    For Signal line:
        df['cmo_signal'] = df['cmo'].rolling(window=10).mean().round(2)  # Using SMA for signal

    Returns:
    - pd.DataFrame: DataFrame with 'cmo' column.
    """
    df_copy = df.copy()

    mom = df['close'].diff()
    pos_mom = mom.where(mom > 0, 0)
    neg_mom = -mom.where(mom < 0, 0)
    sm1 = pos_mom.rolling(window=length).sum()
    sm2 = neg_mom.rolling(window=length).sum()
    df_copy['cmo'] = 100 * (sm1 - sm2) / (sm1 + sm2)

    df_copy['cmo'] = df_copy['cmo'].round(2)
    return df_copy[['cmo']]
```

### General Refactoring Steps:

1. **Rename Functions and Columns to Lowercase**:
   - Ensure function names and DataFrame columns are in lowercase.

2. **Add Detailed Descriptions**:
   - Add a brief description of the indicator's purpose at the start of the docstring.
   - Include parameters, usage examples, and return types in the docstring.

3. **Ensure Consistent Output Format**:
   - Ensure that all functions return a DataFrame with the new indicator columns.
   - Limit numeric output to two decimal places using `.round(2)`.

By following these steps, you can ensure that all functions are refactored consistently, making it easier to maintain and understand the code in the future


# Another refactoring prompt:
Sure! Here is a comprehensive prompt you can use to repeat this refactoring exercise in the future:

---

**Refactoring Prompt for Trading Technical Analysis Indicators**

### Objective:
Refactor the code for trading technical analysis indicators to ensure consistency in function structure, input methods, calculation methods, and output methods. Pay special attention to naming conventions, descriptions, and formatting. All functions should return a DataFrame with the new indicator columns, and all column names should be in lowercase. Numeric outputs should be limited to two decimal places.

### Instructions:

1. **Function Name and Description**:
   - Follow PEP-8 naming conventions (e.g., `snake_case` for function names).
   - Include a descriptive docstring detailing the function's purpose, parameters, usage example, and return values.
   - Start the docstring with a brief description of the indicator's purpose and functionality.

2. **Parameters**:
   - Clearly define parameters with default values where appropriate.
   - Explain each parameter in the docstring, including the data type and purpose.

3. **Input Validation**:
   - Ensure the input DataFrame contains the required columns.
   - Raise a `KeyError` if any required columns are missing.

4. **Calculations**:
   - Perform calculations step-by-step, with clear comments if necessary.
   - Use appropriate methods for moving averages (e.g., rolling mean for SMA, exponential weighted mean for EMA).

5. **Output**:
   - Return a DataFrame containing the new indicator columns.
   - Ensure all DataFrame column names are in lowercase.
   - Limit the output values to two decimal places using `.round(2)`.

6. **Example Calls**:
   - Include example calls in the docstring, showing how to use the function.
   - Demonstrate how to add the new columns to the original DataFrame.

### Example Refactored Function:

#### Heikin Ashi (HA) with Optional Pre and Post Smoothing:

```python
def heikin_ashi(df, pre_smoothing_period=None, post_smoothing_period=None):
    """
    Heikin Ashi (HA) with Optional Pre and Post Smoothing

    Heikin Ashi is a type of price chart that shares some characteristics with candlestick charts but differs due to the values used to plot them. 
    This modified version allows for optional smoothing of the original data before the Heikin Ashi calculation and/or smoothing of the Heikin Ashi values themselves, 
    aiming to provide a more refined and smoother representation of price action, making it easier to identify the trend.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - pre_smoothing_period (int, optional): Period for EMA pre-smoothing of the original data. If provided, original price bars are smoothed before Heikin Ashi calculations.
    - post_smoothing_period (int, optional): Period for EMA post-smoothing of Heikin Ashi values. If provided, Heikin Ashi values are smoothed post calculations.

    Call with:
        ha_df = bta.heikin_ashi(df)
        df['ha_close'] = ha_df['ha_close']
        df['ha_open'] = ha_df['ha_open']
        df['ha_high'] = ha_df['ha_high']
        df['ha_low'] = ha_df['ha_low']

    Returns:
    - pd.DataFrame: DataFrame with 'ha_open', 'ha_high', 'ha_low', and 'ha_close' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # If pre-smoothing is required
    if pre_smoothing_period:
        df_copy['open'] = ema(df_copy, 'open', pre_smoothing_period)
        df_copy['close'] = ema(df_copy, 'close', pre_smoothing_period)
        df_copy['high'] = ema(df_copy, 'high', pre_smoothing_period)
        df_copy['low'] = ema(df_copy, 'low', pre_smoothing_period)

    # Regular Heikin Ashi calculations
    df_copy['ha_close'] = (df_copy['open'] + df_copy['high'] +
                           df_copy['low'] + df_copy['close']) / 4
    df_copy.reset_index(inplace=True)
    ha_open = [(df_copy['open'][0] + df_copy['close'][0]) / 2]
    [ha_open.append((ha_open[i] + df_copy['ha_close'].values[i]) / 2)
     for i in range(0, len(df_copy) - 1)]
    df_copy['ha_open'] = ha_open
    df_copy.set_index('index', inplace=True)
    df_copy['ha_high'] = df_copy[['ha_open', 'ha_close', 'high']].max(axis=1)
    df_copy['ha_low'] = df_copy[['ha_open', 'ha_close', 'low']].min(axis=1)

    # If post-smoothing is required
    if post_smoothing_period:
        df_copy['ha_open'] = ema(df_copy, 'ha_open', post_smoothing_period)
        df_copy['ha_high'] = ema(df_copy, 'ha_high', post_smoothing_period)
        df_copy['ha_low'] = ema(df_copy, 'ha_low', post_smoothing_period)
        df_copy['ha_close'] = ema(df_copy, 'ha_close', post_smoothing_period)

    # Limit to two decimal places
    df_copy['ha_open'] = df_copy['ha_open'].round(2)
    df_copy['ha_high'] = df_copy['ha_high'].round(2)
    df_copy['ha_low'] = df_copy['ha_low'].round(2)
    df_copy['ha_close'] = df_copy['ha_close'].round(2)

    return df_copy[['ha_open', 'ha_high', 'ha_low', 'ha_close']]
```

#### Awesome Oscillator (AO):

```python
def awesome_oscillator(df, window1=5, window2=34, fillna=False):
    """
    Awesome Oscillator (AO)

    The Awesome Oscillator is a momentum indicator used to measure market momentum.
    It is calculated by subtracting a 34-period simple moving average (SMA) of the
    median price from a 5-period SMA of the median price.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'high' and 'low'.
    - window1 (int, optional): Short period. Default is 5.
    - window2 (int, optional): Long period. Default is 34.
    - fillna (bool, optional): If True, fill nan values with 0. Default is False.

    Call with:
        df['ao'] = bta.awesome_oscillator(df)

    Returns:
    - pd.DataFrame: DataFrame with 'ao' column.
    """
    df_copy = df.copy()

    median_price = 0.5 * (df['high'] + df['low'])
    min_periods_s = 0 if fillna else window1
    min_periods_l = 0 if fillna else window2
    df_copy['ao'] = (
        median_price.rolling(window1, min_periods=min_periods_s).mean()
        - median_price.rolling(window2, min_periods=min_periods_l).mean()
    )
    if fillna:
        df_copy['ao'] = df_copy['ao'].fillna(0)

    df_copy['ao'] = df_copy['ao'].round(2)
    return df_copy[['ao']]
```

#### Chande Momentum Oscillator (CMO):

```python
def chande_momentum_oscillator(df, length=14):
    """
    Chande Momentum Oscillator (CMO)

    The Chande Momentum Oscillator (CMO) is a technical momentum indicator developed by Tushar Chande. 
    It measures the amount that an asset's price has changed over a specified period of time.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - length (int): Length for the CMO calculation. Default is 14.

    Call with:
        df['cmo'] = bta.chande_momentum_oscillator(df)

    For Signal line:
        df['cmo_signal'] = df['cmo'].rolling(window=10).mean().round(2)  # Using SMA for signal

    Returns:
    - pd.DataFrame: DataFrame with 'cmo' column.
    """
    df_copy = df.copy()

    mom = df['close'].diff()
    pos_mom = mom.where(mom > 0, 0)
    neg_mom = -mom.where(mom < 0, 0)
    sm1 = pos_mom.rolling(window=length).sum()
    sm2 = neg_mom.rolling(window=length).sum()
    df_copy['cmo'] = 100 * (sm1 - sm2) / (sm1 + sm2)

    df_copy['cmo'] = df_copy['cmo'].round(2)
    return df_copy[['cmo']]
```

### General Refactoring Steps:

1. **Rename Functions and Columns to Lowercase**:
   - Ensure function names and DataFrame columns are in lowercase.

2. **Add Detailed Descriptions**:
   - Add a brief description of the indicator's purpose at the start of the docstring.
   - Include parameters

, usage examples, and return types in the docstring.

3. **Ensure Consistent Output Format**:
   - Ensure that all functions return a DataFrame with the new indicator columns.
   - Limit numeric output to two decimal places using `.round(2)`.

By following these steps and examples, you can ensure that all functions are refactored consistently, making it easier to maintain and understand the code in the future.

---

Feel free to adjust the prompt and instructions as needed for your specific requirements.


    ----- End of prompts.md -----

    requirements.txt

    ----- Start of requirements.txt -----

ta
numpy
pandas
pandas_ta

    ----- End of requirements.txt -----

    setup.py

    ----- Start of setup.py -----

from setuptools import setup, find_packages
import os

here = os.path.abspath(os.path.dirname(__file__))

VERSION = '0.0.6'
DESCRIPTION = 'TA library for Pandas'

with open("README.md", "r") as f:
    LONG_DESCRIPTION = f.read()

# Setting up
setup(
    name="bamboo-ta",
    version=VERSION,
    author="DutchCryptoDad (DCD)",
    author_email="<dutchcryptodad@gmail.com>",
    url="https://github.com/DutchCryptoDad/bamboo-ta",
    description=DESCRIPTION,
    long_description_content_type="text/markdown",
    long_description=LONG_DESCRIPTION,
    packages=find_packages(),
    keywords=['python', 'pandas', 'numpy',
              'trading', 'indicator', 'technical analysis'],
    classifiers=[
        "Development Status :: 1 - Planning",
        "Intended Audience :: Developers",
        "Programming Language :: Python :: 3",
        "Operating System :: Unix",
        "Operating System :: MacOS :: MacOS X",
        "Operating System :: Microsoft :: Windows",
    ],
    install_requires=['pandas', 'numpy'],
    extras_require={
        "def": ["pytest", "twine"],
    },
    python_requres=">=3.10",
)

    ----- End of setup.py -----

    .vscode/
        settings.json

        ----- Start of settings.json -----

{
    "[python]": {
        "editor.defaultFormatter": "ms-python.autopep8"
    },
    "python.formatting.provider": "none"
}
        ----- End of settings.json -----

    bamboo_ta/
        bamboo_ta.py

        ----- Start of bamboo_ta.py -----

# bamboo_ta.py
# -*- coding: utf-8 -*-
# Import the individual bamboo ta libraries
from bamboo_ta.candles import *
from bamboo_ta.cycles import *
from bamboo_ta.momentum import *
from bamboo_ta.performance import *
from bamboo_ta.statistics import *
from bamboo_ta.trend import *
from bamboo_ta.utility import *
from bamboo_ta.volatility import *
from bamboo_ta.volume import *
        ----- End of bamboo_ta.py -----

        candles.py

        ----- Start of candles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import *
from .utility import *
from.momentum import *


def ExhaustionBars(df, maj_qual=6, maj_len=30, min_qual=5, min_len=5, core_length=4):
    """
    Leledc Exhaustion Bars

    Infamous S/R Reversal Indicator

    Leledc exhaustion bars are a specific type of price action pattern used in technical analysis to identify potential reversals in the market trend. These bars are characterized by a sharp move in price with an increase in volume, often indicating that the current trend is losing momentum and may reverse direction soon. Traders use them to pinpoint the end of a trend and the beginning of a new one, thereby making more informed trading decisions.

    For more information, see: https://www.abundancetradinggroup.com/leledc-exhaustion-bar-mt4-indicator/
    
    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'open', 'high', 'low', and 'close' columns.
    - maj_qual (int): Major quality parameter. Default is 6.
    - maj_len (int): Major length parameter. Default is 30.
    - min_qual (int): Minor quality parameter. Default is 5.
    - min_len (int): Minor length parameter. Default is 5.
    - core_length (int): Core length parameter. Default is 4.

    Call with:
        exhaustion = bta.ExhaustionBars(df)
        df['leledc_major'] = exhaustion['leledc_major']
        df['leledc_minor'] = exhaustion['leledc_minor']

    Returns:
    - pd.DataFrame: DataFrame with 'leledc_major' and 'leledc_minor' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    bindex_maj, sindex_maj, trend_maj = 0, 0, 0
    bindex_min, sindex_min = 0, 0

    for i in range(len(df_copy)):
        close = df_copy['close'][i]

        if i < 1 or i - core_length < 0:
            df_copy.loc[i, 'leledc_major'] = np.nan
            df_copy.loc[i, 'leledc_minor'] = 0
            continue

        bindex_maj, sindex_maj = np.nan_to_num(bindex_maj), np.nan_to_num(sindex_maj)
        bindex_min, sindex_min = np.nan_to_num(bindex_min), np.nan_to_num(sindex_min)

        if close > df_copy['close'][i - core_length]:
            bindex_maj += 1
            bindex_min += 1
        elif close < df_copy['close'][i - core_length]:
            sindex_maj += 1
            sindex_min += 1

        update_major = False
        if bindex_maj > maj_qual and close < df_copy['open'][i] and df_copy['high'][i] >= df_copy['high'][i - maj_len:i].max():
            bindex_maj, trend_maj, update_major = 0, 1, True
        elif sindex_maj > maj_qual and close > df_copy['open'][i] and df_copy['low'][i] <= df_copy['low'][i - maj_len:i].min():
            sindex_maj, trend_maj, update_major = 0, -1, True

        df_copy.loc[i, 'leledc_major'] = trend_maj if update_major else np.nan if trend_maj == 0 else trend_maj

        if bindex_min > min_qual and close < df_copy['open'][i] and df_copy['high'][i] >= df_copy['high'][i - min_len:i].max():
            bindex_min = 0
            df_copy.loc[i, 'leledc_minor'] = -1
        elif sindex_min > min_qual and close > df_copy['open'][i] and df_copy['low'][i] <= df_copy['low'][i - min_len:i].min():
            sindex_min = 0
            df_copy.loc[i, 'leledc_minor'] = 1
        else:
            df_copy.loc[i, 'leledc_minor'] = 0

    return df_copy[['leledc_major', 'leledc_minor']]


def DynamicExhaustionBars(df, window=500):
    """
    Dynamic Leledc Exhaustion Bars
    The lookback length and exhaustion bars adjust dynamically to the market conditions.

    This indicator dynamically adjusts the lookback length and the exhaustion bars based on the market's behavior, helping to identify potential reversals and trend strength.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - window (int): Lookback window for z-score calculation. Default is 500.

    Call with:
        dynamic_exhaustion = bta.DynamicExhaustionBars(df)
        df['dynamic_leledc_major'] = dynamic_exhaustion['leledc_major']
        df['dynamic_leledc_minor'] = dynamic_exhaustion['leledc_minor']

    Returns:
    - pd.DataFrame: DataFrame with 'leledc_major' and 'leledc_minor' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    df_copy['close_pct_change'] = df_copy['close'].pct_change()
    df_copy['pct_change_zscore'] = ZScore(df_copy['close_pct_change'], window)
    df_copy['pct_change_zscore_smoothed'] = df_copy['pct_change_zscore'].rolling(window=3).mean()
    df_copy['pct_change_zscore_smoothed'] = df_copy['pct_change_zscore_smoothed'].fillna(1.0)

    zscore = df_copy['pct_change_zscore_smoothed'].to_numpy()
    zscore_multi = np.maximum(np.minimum(5.0 - zscore * 2, 5.0), 1.5)

    maj_qual, min_qual = Calculate_Exhaustion_Candles(df_copy, window, zscore_multi)
    
    df_copy['maj_qual'] = maj_qual
    df_copy['min_qual'] = min_qual

    maj_len, min_len = Calculate_Exhaustion_Lengths(df_copy)
    
    df_copy['maj_len'] = maj_len
    df_copy['min_len'] = min_len

    df_copy = populate_leledc_major_minor(df_copy, maj_qual, min_qual, maj_len, min_len)

    return df_copy[['leledc_major', 'leledc_minor']]


# def Pinbar(df: pd.DataFrame, smi: pd.Series = None) -> pd.DataFrame:
#     """
#     Pinbar - Price Action Indicator

#     Pinbars are an easy but sure indication of incoming price reversal.
#     Signal confirmation with SMI (Stochastic Momentum Index) can enhance the accuracy of the signals.

#     Parameters:
#     - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', and 'close' columns.
#     - smi (pandas.Series, optional): Optional Series for SMI. If not provided, it will be calculated internally.

#     Call with:
#         pin = bta.Pinbar(df)
#         df['pinbar_sell'] = pin['pinbar_sell']
#         df['pinbar_buy'] = pin['pinbar_buy']

#     Returns:
#     - pd.DataFrame: DataFrame with 'pinbar_sell' and 'pinbar_buy' columns populated.
#     """
#     df_copy = df.copy()

#     # Ensure the DataFrame contains the required columns
#     required_columns = ['high', 'low', 'close']
#     for col in required_columns:
#         if col not in df.columns:
#             raise KeyError(f"DataFrame must contain '{col}' column")

#     low = df_copy['low']
#     high = df_copy['high']
#     close = df_copy['close']
    
#     tr = TrueRange(df_copy)['true_range']
    
#     if smi is None:
#         df_copy = StochasticMomentumIndex(df_copy)
#         smi = df_copy['smi']
    
#     df_copy['pinbar_sell'] = (
#         (high < high.shift(1)) &
#         (close < high - (tr * 2 / 3).iloc[:]) &
#         (smi < smi.shift(1)) &
#         (smi.shift(1) > 40) &
#         (smi.shift(1) < smi.shift(2))
#     )

#     df_copy['pinbar_buy'] = (
#         (low > low.shift(1)) &
#         (close > low + (tr * 2 / 3).iloc[:]) &
#         (smi.shift(1) < -40) &
#         (smi > smi.shift(1)) &
#         (smi.shift(1) > smi.shift(2))
#     )
    
#     return df_copy[['pinbar_sell', 'pinbar_buy']]


def HeikinAshi(df, pre_smoothing_period=None, post_smoothing_period=None):
    """
    Heikin Ashi (HA) with Optional Pre and Post Smoothing

    Heikin Ashi is a type of price chart that shares some characteristics with candlestick charts but differs due to the values used to plot them. 
    This modified version allows for optional smoothing of the original data before the Heikin Ashi calculation and/or smoothing of the Heikin Ashi values themselves, 
    aiming to provide a more refined and smoother representation of price action, making it easier to identify the trend.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - pre_smoothing_period (int, optional): Period for EMA pre-smoothing of the original data. If provided, original price bars are smoothed before Heikin Ashi calculations.
    - post_smoothing_period (int, optional): Period for EMA post-smoothing of Heikin Ashi values. If provided, Heikin Ashi values are smoothed post calculations.

    Call with:
        ha_df = bta.HeikinAshi(df)
        df['ha_open'] = ha_df['ha_open']
        df['ha_high'] = ha_df['ha_high']
        df['ha_low'] = ha_df['ha_low']
        df['ha_close'] = ha_df['ha_close']

    Returns:
    - pd.DataFrame: DataFrame with 'ha_open', 'ha_high', 'ha_low', and 'ha_close' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # If pre-smoothing is required
    if pre_smoothing_period:
        df_copy['open'] = EMA(df_copy, 'open', pre_smoothing_period)
        df_copy['close'] = EMA(df_copy, 'close', pre_smoothing_period)
        df_copy['high'] = EMA(df_copy, 'high', pre_smoothing_period)
        df_copy['low'] = EMA(df_copy, 'low', pre_smoothing_period)

    # Regular Heikin Ashi calculations
    df_copy['ha_close'] = (df_copy['open'] + df_copy['high'] +
                           df_copy['low'] + df_copy['close']) / 4
    df_copy.reset_index(inplace=True)
    ha_open = [(df_copy['open'][0] + df_copy['close'][0]) / 2]
    [ha_open.append((ha_open[i] + df_copy['ha_close'].values[i]) / 2)
     for i in range(0, len(df_copy) - 1)]
    df_copy['ha_open'] = ha_open
    df_copy.set_index('index', inplace=True)
    df_copy['ha_high'] = df_copy[['ha_open', 'ha_close', 'high']].max(axis=1)
    df_copy['ha_low'] = df_copy[['ha_open', 'ha_close', 'low']].min(axis=1)

    # If post-smoothing is required
    if post_smoothing_period:
        df_copy['ha_open'] = EMA(df_copy, 'ha_open', post_smoothing_period)
        df_copy['ha_high'] = EMA(df_copy, 'ha_high', post_smoothing_period)
        df_copy['ha_low'] = EMA(df_copy, 'ha_low', post_smoothing_period)
        df_copy['ha_close'] = EMA(df_copy, 'ha_close', post_smoothing_period)

    # Limit to two decimal places
    df_copy['ha_open'] = df_copy['ha_open'].round(2)
    df_copy['ha_high'] = df_copy['ha_high'].round(2)
    df_copy['ha_low'] = df_copy['ha_low'].round(2)
    df_copy['ha_close'] = df_copy['ha_close'].round(2)

    return df_copy[['ha_open', 'ha_high', 'ha_low', 'ha_close']]


def LinRegCandles(df, linreg_length=11, sma_signal=True, signal_length=11):
    """
    Linear Regression Candles with Optional Signal Line

    The Linear Regression Candles transform the traditional OHLC bars using a linear regression algorithm, providing a smoothed representation of price action. The function also provides an optional signal line, which can be either an SMA or an EMA of the Linear Regression Candle close. This signal line can help to identify trends and potential trading signals.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - linreg_length (int, optional): Period for linear regression calculation. Default is 11.
    - sma_signal (bool, optional): If True, uses SMA for the signal line. If False, uses EMA. Default is True.
    - signal_length (int, optional): Period for the moving average signal line. Default is 11.

    Call with:
        lr_df = bta.LinRegCandles(df)
        df['lrc_open'] = lr_df['bopen']
        df['lrc_high'] = lr_df['bhigh']
        df['lrc_low'] = lr_df['blow']
        df['lrc_close'] = lr_df['bclose']
        df['lrc_signal'] = lr_df['signal']

    Returns:
    - pd.DataFrame: DataFrame with 'bopen', 'bhigh', 'blow', 'bclose' as the Linear Regression Candles, and 'signal' as the signal line.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate linear regression coefficients for open, high, low, and close
    df_copy['bopen'] = df_copy['open'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bhigh'] = df_copy['high'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['blow'] = df_copy['low'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    df_copy['bclose'] = df_copy['close'].rolling(window=linreg_length).apply(
        lambda x: np.polyfit(np.arange(len(x)), x, 1)[1] + np.polyfit(np.arange(len(x)), x, 1)[0] * (len(x) - 1),
        raw=True
    )

    # Calculate the signal line using SMA or EMA
    if sma_signal:
        df_copy['signal'] = df_copy['bclose'].rolling(window=signal_length).mean()
    else:
        df_copy['signal'] = df_copy['bclose'].ewm(span=signal_length, adjust=False).mean()

    # Limit to two decimal places
    df_copy['bopen'] = df_copy['bopen'].round(2)
    df_copy['bhigh'] = df_copy['bhigh'].round(2)
    df_copy['blow'] = df_copy['blow'].round(2)
    df_copy['bclose'] = df_copy['bclose'].round(2)
    df_copy['signal'] = df_copy['signal'].round(2)

    return df_copy[['bopen', 'bhigh', 'blow', 'bclose', 'signal']]

        ----- End of candles.py -----

        cycles.py

        ----- Start of cycles.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of cycles.py -----

        momentum.py

        ----- Start of momentum.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import *
from .volatility import *
from .utility import *


def AwesomeOscillator(df: pd.DataFrame, high_col: str = 'high', low_col: str = 'low', window1: int = 5, window2: int = 34, fillna: bool = False) -> pd.DataFrame:
    """
    Awesome Oscillator (AO)

    The Awesome Oscillator is a momentum indicator used to measure market momentum.
    It is calculated by subtracting a 34-period simple moving average (SMA) of the
    median price from a 5-period SMA of the median price.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing 'high' and 'low' columns.
    - high_col (str): The name of the 'high' column. Default is 'high'.
    - low_col (str): The name of the 'low' column. Default is 'low'.
    - window1 (int, optional): Short period. Default is 5.
    - window2 (int, optional): Long period. Default is 34.
    - fillna (bool, optional): If True, fill nan values with 0. Default is False.

    Call with:
        df['ao'] = bta.AwesomeOscillator(df, 'high', 'low', 5, 34)['ao']

    Returns:
    - pd.DataFrame: DataFrame with the 'ao' column.
    """
    df_copy = df.copy()

    median_price = 0.5 * (df_copy[high_col] + df_copy[low_col])
    min_periods_s = 0 if fillna else window1
    min_periods_l = 0 if fillna else window2

    df_copy['ao'] = (
        median_price.rolling(window1, min_periods=min_periods_s).mean()
        - median_price.rolling(window2, min_periods=min_periods_l).mean()
    )
    if fillna:
        df_copy['ao'] = df_copy['ao'].fillna(0)

    df_copy['ao'] = df_copy['ao'].round(2)
    
    return df_copy[['ao']]


def ChandeMomentumOscillator(df, length: int = 14) -> pd.DataFrame:
    """
    Chande Momentum Oscillator (CMO)

    The Chande Momentum Oscillator (CMO) is a technical momentum indicator developed by Tushar Chande. 
    It measures the amount that an asset's price has changed over a specified period of time.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - length (int): Length for the CMO calculation. Default is 14.

    Call with:
        df['cmo'] = bta.ChandeMomentumOscillator(df)

    For Signal line:
        df['cmo_signal'] = df['cmo'].rolling(window=10).mean().round(2)  # Using SMA for signal

    Returns:
    - pd.DataFrame: DataFrame with 'cmo' column.
    """
    df_copy = df.copy()

    mom = df['close'].diff()
    pos_mom = mom.where(mom > 0, 0)
    neg_mom = -mom.where(mom < 0, 0)
    sm1 = pos_mom.rolling(window=length).sum()
    sm2 = neg_mom.rolling(window=length).sum()
    df_copy['cmo'] = 100 * (sm1 - sm2) / (sm1 + sm2)

    df_copy['cmo'] = df_copy['cmo'].round(2)
    return df_copy[['cmo']]


def ElliottWaveOscillator(df, column: str = 'close', sma1_period: int = 5, sma2_period: int = 35) -> pd.DataFrame:
    """
    Elliott Wave Oscillator (EWO)

    The Elliott Wave Oscillator (EWO) is a specific tool to help you identify the trend and the overall market pattern to assist in finding future trading opportunities.
    It is derived by calculating the difference between a short and long period simple moving average, then normalizing the result with the close price.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EWO is to be calculated. Default is "close".
    - sma1_period (int): The period for the shorter SMA used in EWO calculation. Default is 5.
    - sma2_period (int): The period for the longer SMA used in EWO calculation. Default is 35.

    Call with:
        df['ewo'] = bta.ElliottWaveOscillator(df, "close", 5, 35)

    Returns:
    - pd.DataFrame: DataFrame with 'ewo' column.
    """
    df_copy = df.copy()

    sma1 = df[column].rolling(window=sma1_period).mean()
    sma2 = df[column].rolling(window=sma2_period).mean()
    df_copy['ewo'] = ((sma1 - sma2) / df[column] * 100).round(2)

    return df_copy[['ewo']]


def EhlersFisherStochasticCenterOfGravity(df, length: int = 8) -> pd.DataFrame:
    """
    Ehlers Fisher Stochastic Center of Gravity Indicator

    The Fisher Stochastic Center of Gravity indicator, developed by John Ehlers, is used to identify potential
    turning points in the market by calculating the center of gravity of price movements.

    Inspired by: https://ninjatraderecosystem.com/user-app-share-download/john-ehlers-the-fisher-stochastic-center-of-gravity/
    and: https://fxstill.com/indikators/the-fisher-stochastic-center-of-gravity
    and: https://viewer.mathworks.com/?viewer=plain_code&url=https%3A%2F%2Fes.mathworks.com%2Fmatlabcentral%2Fmlc-downloads%2Fdownloads%2F5a9e5f01-906c-4152-98c6-87484eed86bf%2F853ab8ad-8751-4bcd-ae00-60a9444e9182%2Ffiles%2Fmatlab%2FChapter4-Ehlers%2FEhlerStochCG.m&embed=web
    and: https://www.tradingview.com/script/TLjl71aL-Ehlers-Fisher-Stochastic-Center-Of-Gravity-CC/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'high', 'low'.
    - length (int): Period for the indicator. Default is 8.

    Call with:
        fscg = EhlersFisherStochasticCenterOfGravity(df)
        df['CG'] = fscg['CG']
        df['Trigger'] = fscg['Trigger']

    Returns:
    - pd.DataFrame: DataFrame with 'CG' and 'Trigger' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    Price = (df['high'] + df['low']) / 2

    # Initialize series
    Num = pd.Series([0.0] * len(df), index=df.index)
    Denom = pd.Series([0.0] * len(df), index=df.index)
    sg = pd.Series([0.0] * len(df), index=df.index)

    MINBAR = length + 1
    l = (length + 1) / 2

    # Calculate CG
    for i in range(MINBAR, len(df)):
        num = 0.0
        denom = 0.0
        for count in range(length):
            num += (1 + count) * Price.iloc[i - count]
            denom += Price.iloc[i - count]
        
        if denom != 0:
            sg.iloc[i] = l - num / denom
        else:
            sg.iloc[i] = 0.0

        max_cg = sg.iloc[i-length+1:i+1].max()
        min_cg = sg.iloc[i-length+1:i+1].min()

        if max_cg != min_cg:
            Num.iloc[i] = (sg.iloc[i] - min_cg) / (max_cg - min_cg)
        else:
            Num.iloc[i] = 0.0

        Denom.iloc[i] = (4 * Num.iloc[i] + 3 * Num.iloc[i - 1] + 2 * Num.iloc[i - 2] + Num.iloc[i - 3]) / 10

    # Calculate Value3 (V3) and Trigger
    V3 = 0.5 * np.log((1 + 1.98 * (Denom - 0.5)) / (1 - 1.98 * (Denom - 0.5)))
    Trigger = V3.shift(1)

    df_copy['CG'] = V3.round(2)
    df_copy['Trigger'] = Trigger.round(2)

    return df_copy[['CG', 'Trigger']]


def KaufmansAdaptiveMovingAverage(
    df: pd.DataFrame,
    close_col: str = 'close',
    window: int = 14,
    pow1: int = 2,
    pow2: int = 30,
    fillna: bool = False,
) -> pd.DataFrame:
    """
    Kaufman's Adaptive Moving Average (KAMA)

    Moving average designed to account for market noise or volatility. KAMA
    will closely follow prices when the price swings are relatively small and
    the noise is low. KAMA will adjust when the price swings widen and follow
    prices from a greater distance. This trend-following indicator can be
    used to identify the overall trend, time turning points and filter price
    movements.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the 'close' column.
    - close_col (str): Column name for the close prices. Default is 'close'.
    - window (int): Number of periods for the efficiency ratio. Default is 10.
    - pow1 (int): Number of periods for the fastest EMA constant. Default is 2.
    - pow2 (int): Number of periods for the slowest EMA constant. Default is 30.
    - fillna (bool): If True, fill nan values with the close prices. Default is False.

    Call with:
        df['kama'] = bta.KaufmansAdaptiveMovingAverage(df)['kama']

    Returns:
    - pd.DataFrame: DataFrame with 'kama' column.
    """
    close = df[close_col]
    close_values = close.values
    vol = pd.Series(abs(close - np.roll(close, 1)))

    min_periods = 0 if fillna else window
    er_num = abs(close_values - np.roll(close_values, window))
    er_den = vol.rolling(window, min_periods=min_periods).sum()
    efficiency_ratio = np.divide(
        er_num, er_den, out=np.zeros_like(er_num), where=er_den != 0
    )

    smoothing_constant = (
        (
            efficiency_ratio * (2.0 / (pow1 + 1) - 2.0 / (pow2 + 1.0))
            + 2 / (pow2 + 1.0)
        )
        ** 2.0
    ).values

    kama = np.zeros(smoothing_constant.size)
    len_kama = len(kama)
    first_value = True

    for i in range(len_kama):
        if np.isnan(smoothing_constant[i]):
            kama[i] = np.nan
        elif first_value:
            kama[i] = close_values[i]
            first_value = False
        else:
            kama[i] = kama[i - 1] + smoothing_constant[i] * (
                close_values[i] - kama[i - 1]
            )
    
    kama_series = pd.Series(kama, index=close.index).round(2)
    if fillna:
        kama_series = kama_series.fillna(close)

    df_copy = df.copy()
    df_copy['kama'] = kama_series

    return df_copy[['kama']]


def MACD(df, column: str = 'close', short_window: int = 12, long_window: int = 26, signal_window: int = 9) -> pd.DataFrame:
    """
    Moving Average Convergence Divergence (MACD)

    MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security’s price.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the "close" column.
    - column (str): The column on which MACD is to be calculated. Default is "close".
    - short_window (int): The short-term period for EMA. Default is 12.
    - long_window (int): The long-term period for EMA. Default is 26.
    - signal_window (int): The signal line period for EMA. Default is 9.

    Call with:
        macd_result = bta.MACD(df, 'close', 12, 26, 9)
        df['macd'] = macd_result['macd']
        df['macd_signal'] = macd_result['macd_signal']
        df['macd_histogram'] = macd_result['macd_histogram']

    Returns:
    - pd.DataFrame: DataFrame with 'macd', 'macd_signal', and 'macd_histogram' columns.
    """
    def ema_calculation(series, span):
        return series.ewm(span=span, adjust=False).mean()

    short_ema = ema_calculation(df[column], span=short_window)
    long_ema = ema_calculation(df[column], span=long_window)
    macd = short_ema - long_ema
    signal = ema_calculation(macd, span=signal_window)
    histogram = macd - signal

    df_copy = df.copy()
    df_copy['macd'] = macd.round(2)
    df_copy['macd_signal'] = signal.round(2)
    df_copy['macd_histogram'] = histogram.round(2)

    return df_copy[['macd', 'macd_signal', 'macd_histogram']]


def MACDLeader(df: pd.DataFrame, src: str = 'close', fast_length: int = 12, slow_length: int = 26, signal_length: int = 9) -> pd.DataFrame:
    """
    MACD Leader

    The MACD Leader is a variation of the standard MACD that aims to provide an earlier signal by using a different calculation method.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the source column.
    - src (str): The column to use for calculations. Default is 'close'.
    - fast_length (int): Length for the fast EMA. Default is 12.
    - slow_length (int): Length for the slow EMA. Default is 26.
    - signal_length (int): Length for the signal EMA. Default is 9.

    Call with:
        df['macd_leader'] = bta.MACDLeader(df, 'close')['macd_leader']

    Returns:
    - pd.DataFrame: DataFrame with 'macd_leader' column.
    """
    def ema_calculation(series, span):
        return series.ewm(span=span, adjust=False).mean()

    df_copy = df.copy()
    src_series = df[src]

    sema = ema_calculation(src_series, span=fast_length)
    lema = ema_calculation(src_series, span=slow_length)
    diff_sema = src_series - sema
    diff_lema = src_series - lema
    i1 = sema + ema_calculation(diff_sema, span=fast_length)
    i2 = lema + ema_calculation(diff_lema, span=slow_length)
    macd_leader = ((i1 - i2) / 10) * 10

    df_copy['macd_leader'] = macd_leader.round(2)
    
    return df_copy[['macd_leader']]

def MAStreak(df: pd.DataFrame, length: int = 10, src: str = 'close', matype: int = 1) -> pd.DataFrame:
    """
    MA Streak Indicator

    This indicator tracks how many bars a given moving average is rising or falling. 
    It's color-coded green (positive) or red (negative).

    Inspired by: https://www.tradingview.com/script/Yq1z7cIv-MA-Streak-Can-Show-When-a-Run-Is-Getting-Long-in-the-Tooth/

    Call with:
        df['ma_streak'] = bta.MAStreak(df, length=10, src='close', matype=1)['ma_streak']

    MA types:
    1 - Simple Moving Average (SMA)
    2 - Exponential Moving Average (EMA)
    3 - Hull Moving Average (HMA)
    4 - Weighted Moving Average (WMA)
    5 - Volume Weighted Moving Average (VWMA)

    Parameters:
    - df (pd.DataFrame): Input DataFrame containing the data.
    - length (int): Period for the moving average calculation. Default is 10.
    - src (str): The column name to use for the moving average calculation. Default is 'close'.
    - matype (int): Type of moving average to use. Default is 1 (SMA).

    Returns:
    - pd.DataFrame: DataFrame with 'ma_streak' column.
    """
    df_copy = df.copy()

    # Calculate different types of moving averages
    df_copy['sma'] = df_copy[src].rolling(window=length).mean()
    df_copy['ema'] = df_copy[src].ewm(span=length, adjust=False).mean()
    df_copy['wma'] = df_copy[src].rolling(window=length).apply(lambda prices: np.dot(prices, np.arange(1, length+1))/np.arange(1, length+1).sum(), raw=True)
    df_copy['vwma'] = (df_copy[src] * df_copy['volume']).rolling(window=length).sum() / df_copy['volume'].rolling(window=length).sum()
    
    # Calculate Hull Moving Average (HMA)
    half_length = int(length / 2)
    sqrt_length = int(np.sqrt(length))
    df_copy['hma'] = df_copy[src].rolling(window=half_length).mean()
    df_copy['hma'] = 2 * df_copy['hma'] - df_copy[src].rolling(window=length).mean()
    df_copy['hma'] = df_copy['hma'].rolling(window=sqrt_length).mean()

    # Select the appropriate moving average
    if matype == 1:
        df_copy['avgval'] = df_copy['sma']
    elif matype == 2:
        df_copy['avgval'] = df_copy['ema']
    elif matype == 3:
        df_copy['avgval'] = df_copy['hma']
    elif matype == 4:
        df_copy['avgval'] = df_copy['wma']
    elif matype == 5:
        df_copy['avgval'] = df_copy['vwma']
    else:
        raise ValueError("Invalid moving average type. Choose a value between 1 and 5.")

    # Initialize the streak columns
    df_copy['upcount'] = 0
    df_copy['dncount'] = 0
    df_copy['ma_streak'] = 0

    # Calculate the streak
    for i in range(1, len(df_copy)):
        if df_copy['avgval'].iloc[i] > df_copy['avgval'].iloc[i - 1]:
            df_copy.at[i, 'upcount'] = df_copy.at[i - 1, 'upcount'] + 1
            df_copy.at[i, 'dncount'] = 0
        elif df_copy['avgval'].iloc[i] < df_copy['avgval'].iloc[i - 1]:
            df_copy.at[i, 'dncount'] = df_copy.at[i - 1, 'dncount'] - 1
            df_copy.at[i, 'upcount'] = 0
        df_copy.at[i, 'ma_streak'] = df_copy.at[i, 'upcount'] + df_copy.at[i, 'dncount']

    return df_copy[['ma_streak']]


def PercentagePriceOscillator(
    df: pd.DataFrame,
    close_col: str = 'close',
    window_slow: int = 26,
    window_fast: int = 12,
    window_sign: int = 9,
    fillna: bool = False
) -> pd.DataFrame:
    """
    Percentage Price Oscillator (PPO) Combined Function

    This function calculates and returns the PPO, PPO Signal, and PPO Histogram values.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the close column.
    - close_col (str): Name of the column containing close price data. Default is 'close'.
    - window_slow (int): n period long-term. Default is 26.
    - window_fast (int): n period short-term. Default is 12.
    - window_sign (int): n period to signal. Default is 9.
    - fillna (bool): if True, fill nan values. Default is False.

    Call with:
        ppo = bta.PercentagePriceOscillator(df)
        df['ppo'] = ppo['ppo']
        df['ppo_signal'] = ppo['ppo_signal']
        df['ppo_hist'] = ppo['ppo_hist']

    Returns:
    - pd.DataFrame: DataFrame with columns ['ppo', 'ppo_signal', 'ppo_hist'].
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    if close_col not in df.columns:
        raise KeyError(f"DataFrame must contain '{close_col}' column")

    close = df_copy[close_col]

    # Calculate EMA
    emafast = close.ewm(span=window_fast, adjust=False).mean()
    emaslow = close.ewm(span=window_slow, adjust=False).mean()
    ppo = ((emafast - emaslow) / emaslow) * 100

    ppo_signal = ppo.ewm(span=window_sign, adjust=False).mean()
    ppo_hist = ppo - ppo_signal

    if fillna:
        ppo = ppo.fillna(0)
        ppo_signal = ppo_signal.fillna(0)
        ppo_hist = ppo_hist.fillna(0)

    df_copy['ppo'] = ppo.round(2)
    df_copy['ppo_signal'] = ppo_signal.round(2)
    df_copy['ppo_hist'] = ppo_hist.round(2)

    return df_copy[['ppo', 'ppo_signal', 'ppo_hist']]


def PercentageVolumeOscillator(
    df: pd.DataFrame,
    volume_col: str = 'volume',
    window_slow: int = 26,
    window_fast: int = 12,
    window_sign: int = 9,
    fillna: bool = False
) -> pd.DataFrame:
    """
    Percentage Volume Oscillator (PVO) Combined Function
    
    This function calculates and returns the PVO, PVO Signal, and PVO Histogram values.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the volume column.
    - volume_col (str): Name of the column containing volume data. Default is 'volume'.
    - window_slow (int): n period long-term. Default is 26.
    - window_fast (int): n period short-term. Default is 12.
    - window_sign (int): n period to signal. Default is 9.
    - fillna (bool): if True, fill nan values. Default is False.

    Call with:
        pvo = bta.PercentageVolumeOscillator(df)
        df['pvo'] = pvo['pvo']
        df['pvo_signal'] = pvo['pvo_signal']
        df['pvo_hist'] = pvo['pvo_hist']

    Returns:
    - pd.DataFrame: DataFrame with columns ['pvo', 'pvo_signal', 'pvo_hist'].
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    if volume_col not in df.columns:
        raise KeyError(f"DataFrame must contain '{volume_col}' column")

    volume = df_copy[volume_col]

    # Calculate EMA
    emafast = volume.ewm(span=window_fast, adjust=False).mean()
    emaslow = volume.ewm(span=window_slow, adjust=False).mean()
    pvo = ((emafast - emaslow) / emaslow) * 100

    pvo_signal = pvo.ewm(span=window_sign, adjust=False).mean()
    pvo_hist = pvo - pvo_signal

    if fillna:
        pvo = pvo.fillna(0)
        pvo_signal = pvo_signal.fillna(0)
        pvo_hist = pvo_hist.fillna(0)

    df_copy['pvo'] = pvo.round(2)
    df_copy['pvo_signal'] = pvo_signal.round(2)
    df_copy['pvo_hist'] = pvo_hist.round(2)

    return df_copy[['pvo', 'pvo_signal', 'pvo_hist']]


def RelativeMomentumIndex(df, length: int = 20, mom: int = 5) -> pd.DataFrame:
    """
    Relative Momentum Index (RMI)

    The Relative Momentum Index (RMI) is an oscillator that applies the RSI formula to momentum rather than price.

    Source: https://www.tradingview.com/script/DdT7MmPa/ and https://github.com/freqtrade/technical/blob/master/technical/indicators/indicators.py#L912  

    Parameters:
    - df (pd.DataFrame): DataFrame containing the data.
    - length (int): Period for the EMA calculation. Default is 20.
    - mom (int): Momentum period. Default is 5.

    Call with:
        df['rmi'] = bta.RelativeMomentumIndex(df, length=20, mom=5)['rmi']

    Returns:
    - pd.DataFrame: DataFrame with 'rmi' column.
    """
    df_copy = df.copy()

    df_copy['maxup'] = (df_copy['close'] - df_copy['close'].shift(mom)).clip(lower=0)
    df_copy['maxdown'] = (df_copy['close'].shift(mom) - df_copy['close']).clip(lower=0)
    df_copy.fillna(0, inplace=True)
    df_copy["ema_inc"] = EMA(df_copy, column='maxup', period=length)
    df_copy["ema_dec"] = EMA(df_copy, column='maxdown', period=length)
    df_copy['rmi'] = np.where(df_copy['ema_dec'] == 0, 0, 100 - 100 / (1 + df_copy["ema_inc"] / df_copy["ema_dec"]))

    df_copy['rmi'] = df_copy['rmi'].round(2)
    
    return df_copy[['rmi']]


def RateOfChange(df, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Rate of Change (ROC)

    The Rate of Change (ROC) is a momentum oscillator that measures the percentage change in price between the current price and the price n periods ago.

    Parameters:
    - df (pd.DataFrame): DataFrame containing the data.
    - column (str): The column name on which the ROC is to be applied. Default is 'close'.
    - period (int): Period for the ROC calculation. Default is 21.

    Call with:
        df['roc'] = bta.RateOfChange(df, column='close', period=21)['roc']

    Returns:
    - pd.DataFrame: DataFrame with 'roc' column.
    """
    df_copy = df.copy()

    df_copy['roc'] = df_copy[column].diff(period) / df_copy[column].shift(period) * 100
    df_copy['roc'] = df_copy['roc'].round(2)
    
    return df_copy[['roc']]


def SmoothedRateOfChange(df, roclen: int = 21, emalen: int = 13, smooth: int = 21) -> pd.DataFrame:
    """
    Smoothed Rate of Change (SROC)

    The Smoothed Rate of Change (SROC) is a momentum oscillator that applies an exponential moving average (EMA) to the Rate of Change (ROC) to smooth out short-term fluctuations.

    Parameters:
    - df (pd.DataFrame): DataFrame containing the data.
    - roclen (int): Period for the ROC calculation. Default is 21.
    - emalen (int): Period for the EMA calculation. Default is 13.
    - smooth (int): Smoothing period for the ROC calculation. Default is 21.

    Call with:
        df['sroc'] = bta.SmoothedRateOfChange(df, roclen=21, emalen=13, smooth=21)['sroc']

    Returns:
    - pd.DataFrame: DataFrame with 'sroc' column.
    """
    df_copy = df.copy()

    # Calculate ROC
    roc = df_copy['close'].diff(roclen) / df_copy['close'].shift(roclen) * 100

    # Calculate EMA of the close price
    ema = df_copy['close'].ewm(span=emalen, adjust=False).mean()

    # Calculate SROC
    sroc = ema.diff(smooth) / ema.shift(smooth) * 100

    df_copy['sroc'] = sroc.round(2)
    
    return df_copy[['sroc']]


def WaddahAttarExplosion(df, sensitivity: int = 150, fast_length: int = 20, slow_length: int = 40, channel_length: int = 20, mult: float = 2.0) -> pd.DataFrame:
    """
    Waddah Attar Explosion Indicator

    The Waddah Attar Explosion indicator is used to identify potential breakout opportunities by combining the MACD and Bollinger Bands.

    Inspired by: https://www.tradingview.com/script/d9IjcYyS-Waddah-Attar-Explosion-V2-SHK/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns: 'open', 'high', 'low', and 'close'.
    - sensitivity (int): Sensitivity factor for the indicator. Default is 150.
    - fast_length (int): Length for the fast EMA. Default is 20.
    - slow_length (int): Length for the slow EMA. Default is 40.
    - channel_length (int): Length for the Bollinger Bands. Default is 20.
    - mult (float): Standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Call with:
        wae = bta.WaddahAttarExplosion(df)
        df['trend_up'] = wae['trend_up']
        df['trend_down'] = wae['trend_down']
        df['explosion_line'] = wae['explosion_line']
        df['dead_zone_line'] = wae['dead_zone_line']

    Returns:
    - pd.DataFrame: DataFrame with 'trend_up', 'trend_down', 'explosion_line', and 'dead_zone_line' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['open', 'high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate EMA
    def calculate_ema(series, period):
        return series.ewm(span=period, adjust=False).mean()
    
    # Calculate RMA
    def calculate_rma(series, period):
        return series.ewm(alpha=1/period, adjust=False).mean()

    # Calculate DEAD_ZONE
    true_range = pd.DataFrame({
        'high_low': df['high'] - df['low'],
        'high_close': (df['high'] - df['close'].shift()).abs(),
        'low_close': (df['low'] - df['close'].shift()).abs()
    })
    true_range['true_range'] = true_range[['high_low', 'high_close', 'low_close']].max(axis=1)
    # dead_zone = RMA(pd.DataFrame(true_range), 'true_range', 100)['rma'] * 3.7
    dead_zone = calculate_rma(true_range['true_range'], 100) * 3.7

    # Calculate MACD
    macd_fast = calculate_ema(df['close'], fast_length)
    macd_slow = calculate_ema(df['close'], slow_length)
    macd_diff = macd_fast - macd_slow
    t1 = (macd_diff - macd_diff.shift(1)) * sensitivity

    # Calculate Bollinger Bands
    bb = BollingerBands(df, column='close', period=channel_length, std_dev=mult)
    e1 = bb['bb_upper'] - bb['bb_lower']

    trend_up = np.where(t1 >= 0, t1, 0)
    trend_down = np.where(t1 < 0, -t1, 0)

    df_copy['trend_up'] = trend_up.round(2)
    df_copy['trend_down'] = trend_down.round(2)
    df_copy['explosion_line'] = e1.round(2)
    df_copy['dead_zone_line'] = dead_zone.values.round(2)

    return df_copy[['trend_up', 'trend_down', 'explosion_line', 'dead_zone_line']]


def WaveTrend(df, chlen: int = 10, avg: int = 21, smalen: int = 4) -> pd.DataFrame:
    """
    WaveTrend Oscillator

    The WaveTrend Oscillator is used to identify overbought and oversold conditions in the market.

    Inspired by:  https://www.tradingview.com/script/2KE8wTuF-Indicator-WaveTrend-Oscillator-WT/ 
    and: https://www.tradingview.com/script/jFQn4jYZ-WaveTrend-with-Crosses-LazyBear/
    
    Parameters:
    - df (pd.DataFrame): DataFrame containing the data.
    - chlen (int): Channel length for the EMA calculation. Default is 10.
    - avg (int): Average period for the EMA calculation. Default is 21.
    - smalen (int): Period for the SMA calculation. Default is 4.

    Call with:
        wt = bta.WaveTrend(df, chlen=10, avg=21, smalen=4)
        df['wt1'] = wt['wt1']
        df['wt2'] = wt['wt2']

    Returns:
    - pd.DataFrame: DataFrame with 'wt1' and 'wt2' columns.
    """
    df_copy = df.copy()

    df_copy['hlc3'] = (df_copy['high'] + df_copy['low'] + df_copy['close']) / 3
    df_copy['esa'] = EMA(df_copy, column='hlc3', period=chlen)
    df_copy['abs_diff'] = (df_copy['hlc3'] - df_copy['esa']).abs()
    df_copy['d'] = EMA(df_copy, column='abs_diff', period=chlen)
    df_copy['ci'] = (df_copy['hlc3'] - df_copy['esa']) / (0.015 * df_copy['d'])
    df_copy['tci'] = EMA(df_copy, column='ci', period=avg)
    df_copy['wt1'] = df_copy['tci']
    df_copy['wt2'] = SMA(df_copy, column='wt1', period=smalen)

    df_copy['wt1'] = df_copy['wt1'].round(2)
    df_copy['wt2'] = df_copy['wt2'].round(2)

    return df_copy[['wt1', 'wt2']]


def WaveTrendOscillator(df: pd.DataFrame, src: str = 'close', n1: int = 8, n2: int = 12) -> pd.DataFrame:
    """
    WaveTrend Oscillator

    The WaveTrend Oscillator is used to identify overbought and oversold conditions in the market.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the source column.
    - src (str): The column to use for calculations. Default is 'close'.
    - n1 (int): Length for the first EMA. Default is 8.
    - n2 (int): Length for the second EMA. Default is 12.

    Call with:
        df['wto'] = bta.WaveTrendOscillator(df, 'close')['wavetrend']

    Returns:
    - pd.DataFrame: DataFrame with 'wavetrend' column.
    """
    df_copy = df.copy()

    src_series = df[src]
    ema_src = EMA(df, column=src, period=n1)['ema']
    diff_series = np.abs(src_series - ema_src)
    d = EMA(pd.DataFrame({'diff': diff_series}), column='diff', period=n1)['ema']
    ci = (src_series - ema_src) / (0.015 * d)
    tci = EMA(pd.DataFrame({'ci': ci}), column='ci', period=n2)['ema']
    wavetrend = tci - SMA(pd.DataFrame({'tci': tci}), column='tci', period=4)['sma']

    df_copy['wavetrend'] = wavetrend.round(2)
    
    return df_copy[['wavetrend']]


def QQEMod(df, rsi_period: int = 6, rsi_smoothing: int = 5, qqe_factor: int = 3, threshold: int = 3, bollinger_length: int = 50, bb_multiplier: float = 0.35, rsi_period2: int = 6, rsi_smoothing2: int = 5, qqe_factor2: float = 1.61, threshold2: int = 3) -> pd.DataFrame:
    """
    QQE Mod Indicator

    The QQE (Quantitative Qualitative Estimation) is a technical analysis indicator that combines the Relative Strength Index (RSI) with a smoothing technique to generate buy and sell signals. The QQE indicator helps traders to identify trends, potential breakouts, and changes in market momentum by providing an enhanced visualization of the underlying price dynamics.

    Inspired by: https://www.tradingview.com/script/TpUW4muw-QQE-MOD/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain a 'close' column.
    - rsi_period (int): Period for RSI calculation. Default is 6.
    - rsi_smoothing (int): Smoothing period for RSI. Default is 5.
    - qqe_factor (int): Fast QQE Factor. Default is 3.
    - threshold (int): Threshold value. Default is 3.
    - bollinger_length (int): Length for Bollinger Bands calculation. Default is 50.
    - bb_multiplier (float): Multiplier for Bollinger Bands. Default is 0.35.
    - rsi_period2 (int): Period for the second RSI calculation. Default is 6.
    - rsi_smoothing2 (int): Smoothing period for the second RSI. Default is 5.
    - qqe_factor2 (float): Fast QQE Factor for the second QQE. Default is 1.61.
    - threshold2 (int): Threshold value for the second QQE. Default is 3.

    Call with:
        qqe_mod = bta.QQEMod(df, 6, 5, 3, 3, 50, 0.35, 6, 5, 1.61, 3)
        df['qqe_line'] = qqe_mod['qqe_line']
        df['histo2'] = qqe_mod['histo2']
        df['qqe_up'] = qqe_mod['qqe_up']
        df['qqe_down'] = qqe_mod['qqe_down']

    Returns:
    - pd.DataFrame: DataFrame with 'qqe_line', 'histo2', 'qqe_up', and 'qqe_down' columns.
    """
    def wilders_ema(series, period):
        return series.ewm(alpha=1/period, adjust=False).mean()

    df_copy = df.copy()

    # First QQE Calculation
    src = df_copy['close']
    wilders_period = rsi_period * 2 - 1

    rsi = RelativeStrengthIndex(df_copy, column='close', period=rsi_period)
    rsi_ma = EMA(df_copy.assign(rsi=rsi), column='rsi', period=rsi_smoothing)['ema']
    atr_rsi = abs(rsi_ma.shift(1) - rsi_ma)
    ma_atr_rsi = wilders_ema(atr_rsi, wilders_period)
    dar = wilders_ema(ma_atr_rsi, wilders_period) * qqe_factor

    longband = np.zeros(len(df_copy))
    shortband = np.zeros(len(df_copy))
    trend = np.zeros(len(df_copy))

    delta_fast_atr_rsi = dar
    rsindex = rsi_ma
    newshortband = rsindex + delta_fast_atr_rsi
    newlongband = rsindex - delta_fast_atr_rsi

    for i in range(1, len(df_copy)):
        if rsindex.iloc[i - 1] > longband[i - 1] and rsindex.iloc[i] > longband[i - 1]:
            longband[i] = max(longband[i - 1], newlongband.iloc[i])
        else:
            longband[i] = newlongband.iloc[i]

        if rsindex.iloc[i - 1] < shortband[i - 1] and rsindex.iloc[i] < shortband[i - 1]:
            shortband[i] = min(shortband[i - 1], newshortband.iloc[i])
        else:
            shortband[i] = newshortband.iloc[i]

        cross_1 = (longband[i - 1] > rsindex.iloc[i]) and (longband[i - 1] <= rsindex.iloc[i - 1])
        if rsindex.iloc[i] > shortband[i - 1]:
            trend[i] = 1
        elif cross_1:
            trend[i] = -1
        else:
            trend[i] = trend[i - 1]

    fast_atr_rsi_tl = np.where(trend == 1, longband, shortband)

    # Bollinger Bands on FastATRRSI TL
    basis = SMA(pd.DataFrame(fast_atr_rsi_tl - 50), column=0, period=bollinger_length)['sma']
    dev = bb_multiplier * (pd.Series(fast_atr_rsi_tl - 50).rolling(window=bollinger_length).std())
    upper = basis + dev
    lower = basis - dev

    # Second QQE Calculation
    wilders_period2 = rsi_period2 * 2 - 1

    rsi2 = RelativeStrengthIndex(df_copy, column='close', period=rsi_period2)
    rsi_ma2 = EMA(df_copy.assign(rsi2=rsi2), column='rsi2', period=rsi_smoothing2)['ema']
    atr_rsi2 = abs(rsi_ma2.shift(1) - rsi_ma2)
    ma_atr_rsi2 = wilders_ema(atr_rsi2, wilders_period2)
    dar2 = wilders_ema(ma_atr_rsi2, wilders_period2) * qqe_factor2

    longband2 = np.zeros(len(df_copy))
    shortband2 = np.zeros(len(df_copy))
    trend2 = np.zeros(len(df_copy))

    delta_fast_atr_rsi2 = dar2
    rsindex2 = rsi_ma2
    newshortband2 = rsindex2 + delta_fast_atr_rsi2
    newlongband2 = rsindex2 - delta_fast_atr_rsi2

    for i in range(1, len(df_copy)):
        if rsindex2.iloc[i - 1] > longband2[i - 1] and rsindex2.iloc[i] > longband2[i - 1]:
            longband2[i] = max(longband2[i - 1], newlongband2.iloc[i])
        else:
            longband2[i] = newlongband2.iloc[i]

        if rsindex2.iloc[i - 1] < shortband2[i - 1] and rsindex2.iloc[i] < shortband2[i - 1]:
            shortband2[i] = min(shortband2[i - 1], newshortband2.iloc[i])
        else:
            shortband2[i] = newshortband2.iloc[i]

        cross_2 = (longband2[i - 1] > rsindex2.iloc[i]) and (longband2[i - 1] <= rsindex2.iloc[i - 1])
        if rsindex2.iloc[i] > shortband2[i - 1]:
            trend2[i] = 1
        elif cross_2:
            trend2[i] = -1
        else:
            trend2[i] = trend2[i - 1]

    fast_atr_rsi2_tl = np.where(trend2 == 1, longband2, shortband2)

    df_copy['qqe_line'] = (fast_atr_rsi2_tl - 50).round(2)
    df_copy['histo2'] = (rsi_ma2 - 50).round(2)

    greenbar1 = rsi_ma2 - 50 > threshold2
    greenbar2 = rsi_ma - 50 > upper

    redbar1 = rsi_ma2 - 50 < -threshold2
    redbar2 = rsi_ma - 50 < lower

    df_copy['qqe_up'] = np.where(greenbar1 & greenbar2, rsi_ma2 - 50, np.nan).round(2)
    df_copy['qqe_down'] = np.where(redbar1 & redbar2, rsi_ma2 - 50, np.nan).round(2)

    return df_copy[['qqe_line', 'histo2', 'qqe_up', 'qqe_down']]


def RelativeStrengthIndex(df, column: str = 'close', period: int = 14) -> pd.DataFrame:
    """
    Relative Strength Index (RSI)

    RSI measures the magnitude of recent price changes to evaluate overbought or oversold conditions in the price of a stock or other asset.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which RSI is to be calculated. Default is "close".
    - period (int): The period over which RSI is to be calculated. Default is 14.

    Call with:
        df['rsi'] = bta.RelativeStrengthIndex(df, column='close', period=14)['rsi']

    Returns:
    - pd.DataFrame: DataFrame with 'rsi' column.
    """
    df_copy = df.copy()

    delta = df_copy[column].diff(1)
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=period, min_periods=1).mean()
    avg_loss = loss.rolling(window=period, min_periods=1).mean()

    for i in range(period, len(df_copy)):
        avg_gain.iloc[i] = (avg_gain.iloc[i - 1] * (period - 1) + gain.iloc[i]) / period
        avg_loss.iloc[i] = (avg_loss.iloc[i - 1] * (period - 1) + loss.iloc[i]) / period

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))

    df_copy['rsi'] = rsi.round(2)

    return df_copy[['rsi']]


def StochasticMomentumIndex(df, k_length=9, d_length=3):
    """
    The Stochastic Momentum Index (SMI) Indicator

    The Stochastic Momentum Index (SMI) Indicator was developed by 
    William Blau in 1993 and is considered to be a momentum indicator 
    that can help identify trend reversal points.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', and 'close' columns.
    - k_length (int): Period for %K. Default is 9.
    - d_length (int): Period for %D. Default is 3.

    Call with:
        df['smi'] = bta.StochasticMomentumIndex(df, k_length=9, d_length=3)['smi']

    Returns:
    - pd.DataFrame: DataFrame with 'smi' column populated.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    ll = df_copy['low'].rolling(window=k_length).min()
    hh = df_copy['high'].rolling(window=k_length).max()

    diff = hh - ll
    rdiff = df_copy['close'] - (hh + ll) / 2

    avgrel = rdiff.ewm(span=d_length).mean().ewm(span=d_length).mean()
    avgdiff = diff.ewm(span=d_length).mean().ewm(span=d_length).mean()

    df_copy['smi'] = np.where(avgdiff != 0, (avgrel / (avgdiff / 2) * 100), 0).round(2)
    
    return df_copy[['smi']]


def StochasticRSI(df, lengthRSI: int = 14, lengthStoch: int = 14, smoothK: int = 3, smoothD: int = 3) -> pd.DataFrame:
    """
    Stochastic RSI (StochasticRSI)
    
    The Stochastic RSI is used to identify overbought and oversold conditions in the market.
    
    Parameters:
    - df (pd.DataFrame): DataFrame containing the data with a 'close' column.
    - lengthRSI (int): Period for the RSI calculation. Default is 14.
    - lengthStoch (int): Period for the Stochastic calculation. Default is 14.
    - smoothK (int): Smoothing period for %K line. Default is 3.
    - smoothD (int): Smoothing period for %D line. Default is 3.
    
    Call with:
        stoch_rsi = bta.StochasticRSI(df, lengthRSI=14, lengthStoch=14, smoothK=3, smoothD=3)
        df['StochasticRSI_K'] = stoch_rsi['stoch_rsi_k']
        df['StochasticRSI_D'] = stoch_rsi['stoch_rsi_d']
    
    Returns:
    - pd.DataFrame: DataFrame with 'stoch_rsi_k' and 'stoch_rsi_d' columns.
    """
    df_copy = df.copy()
    
    # Step 1: Calculate RSI
    delta = df_copy['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=lengthRSI).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=lengthRSI).mean()
    rs = gain / loss
    df_copy['rsi'] = 100 - (100 / (1 + rs))
    
    # Step 2: Calculate the Stochastic Oscillator on RSI
    df_copy['min_rsi'] = df_copy['rsi'].rolling(window=lengthStoch).min()
    df_copy['max_rsi'] = df_copy['rsi'].rolling(window=lengthStoch).max()
    df_copy['stoch_rsi'] = (df_copy['rsi'] - df_copy['min_rsi']) / (df_copy['max_rsi'] - df_copy['min_rsi']) * 100
    
    # Step 3: Smooth the Stochastic RSI values
    df_copy['stoch_rsi_k'] = df_copy['stoch_rsi'].rolling(window=smoothK).mean()
    df_copy['stoch_rsi_d'] = df_copy['stoch_rsi_k'].rolling(window=smoothD).mean()
    
    # Round the results to 2 decimal places
    df_copy['stoch_rsi_k'] = df_copy['stoch_rsi_k'].round(2)
    df_copy['stoch_rsi_d'] = df_copy['stoch_rsi_d'].round(2)
    
    return df_copy[['stoch_rsi_k', 'stoch_rsi_d']]


def TrueStrengthIndex(df, close_col: str ='close', window_slow: int = 25, window_fast: int = 13, fillna: bool = False) -> pd.DataFrame:
    """
    True Strength Index (TSI)

    The True Strength Index (TSI) shows both trend direction and overbought/oversold conditions.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the close column.
    - close_col (str): Name of the column containing close price data. Default is 'close'.
    - window_slow (int): High period. Default is 25.
    - window_fast (int): Low period. Default is 13.
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        df['tsi'] = bta.TrueStrengthIndex(df, 'close', 25, 13)['tsi']

    Returns:
    - pd.DataFrame: DataFrame with 'tsi' column.
    """
    df_copy = df.copy()

    diff_close = df_copy[close_col] - df_copy[close_col].shift(1)
    min_periods_r = 0 if fillna else window_slow
    min_periods_s = 0 if fillna else window_fast
    smoothed = (
        diff_close.ewm(span=window_slow, min_periods=min_periods_r, adjust=False)
        .mean()
        .ewm(span=window_fast, min_periods=min_periods_s, adjust=False)
        .mean()
    )
    smoothed_abs = (
        abs(diff_close)
        .ewm(span=window_slow, min_periods=min_periods_r, adjust=False)
        .mean()
        .ewm(span=window_fast, min_periods=min_periods_s, adjust=False)
        .mean()
    )
    tsi = smoothed / smoothed_abs * 100
    if fillna:
        tsi = tsi.fillna(0)

    df_copy['tsi'] = tsi.round(2)

    return df_copy[['tsi']]


def UltimateOscillator(
    df: pd.DataFrame,
    high_col: str = 'high',
    low_col: str = 'low',
    close_col: str = 'close',
    window1: int = 7,
    window2: int = 14,
    window3: int = 28,
    weight1: float = 4.0,
    weight2: float = 2.0,
    weight3: float = 1.0,
    fillna: bool = False,
) -> pd.DataFrame:
    """
    Ultimate Oscillator

    The Ultimate Oscillator combines short-term, intermediate-term, and long-term price action into one oscillator.

    Parameters:
    - df (pandas.DataFrame): DataFrame containing the data.
    - high_col (str): Name of the column containing high price data. Default is 'high'.
    - low_col (str): Name of the column containing low price data. Default is 'low'.
    - close_col (str): Name of the column containing close price data. Default is 'close'.
    - window1 (int): Short period. Default is 7.
    - window2 (int): Medium period. Default is 14.
    - window3 (int): Long period. Default is 28.
    - weight1 (float): Weight of short BP average for UO. Default is 4.0.
    - weight2 (float): Weight of medium BP average for UO. Default is 2.0.
    - weight3 (float): Weight of long BP average for UO. Default is 1.0.
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        df['uo'] = bta.UltimateOscillator(df, 'high', 'low', 'close', 7, 14, 28)['uo']

    Returns:
    - pd.DataFrame: DataFrame with 'uo' column.
    """
    df_copy = df.copy()

    close_shift = df_copy[close_col].shift(1)
    true_range = np.maximum(df_copy[high_col], close_shift) - np.minimum(df_copy[low_col], close_shift)
    buying_pressure = df_copy[close_col] - np.minimum(df_copy[low_col], close_shift)

    min_periods_s = 0 if fillna else window1
    min_periods_m = 0 if fillna else window2
    min_periods_l = 0 if fillna else window3

    avg_s = (buying_pressure.rolling(window1, min_periods=min_periods_s).sum() /
             true_range.rolling(window1, min_periods=min_periods_s).sum())
    avg_m = (buying_pressure.rolling(window2, min_periods=min_periods_m).sum() /
             true_range.rolling(window2, min_periods=min_periods_m).sum())
    avg_l = (buying_pressure.rolling(window3, min_periods=min_periods_l).sum() /
             true_range.rolling(window3, min_periods=min_periods_l).sum())

    uo = 100.0 * ((weight1 * avg_s) + (weight2 * avg_m) + (weight3 * avg_l)) / (weight1 + weight2 + weight3)
    if fillna:
        uo = uo.fillna(50)
    
    df_copy['uo'] = uo.round(2)

    return df_copy[['uo']]


def StochasticsOscillator(
    df: pd.DataFrame,
    high_col: str = 'high',
    low_col: str = 'low',
    close_col: str = 'close',
    window: int = 14,
    smooth_window: int = 3,
    fillna: bool = False,
) -> pd.DataFrame:
    """
    Stochastic Oscillator, Stochastic Signal, and Histogram Combined.

    The Stochastic Oscillator is a momentum indicator comparing a particular closing price of a security to a range of its prices over a certain period of time.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame.
    - high_col (str): Column name for 'High' prices. Default is 'high'.
    - low_col (str): Column name for 'Low' prices. Default is 'low'.
    - close_col (str): Column name for 'Close' prices. Default is 'close'.
    - window (int): Lookback period for stochastic calculation. Default is 14.
    - smooth_window (int): Lookback period for signal calculation. Default is 3.
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        stoch = bta.StochasticsOscillator(df, 'high', 'low', 'close', 14, 3)
        df['stoch'] = stoch['stoch']
        df['stoch_signal'] = stoch['stoch_signal']
        df['stoch_hist'] = stoch['stoch_hist']

    Returns:
    - pd.DataFrame: DataFrame with 'stoch', 'stoch_signal', and 'stoch_hist' columns.
    """
    df_copy = df.copy()

    high = df_copy[high_col]
    low = df_copy[low_col]
    close = df_copy[close_col]

    min_periods = 0 if fillna else window
    smin = low.rolling(window, min_periods=min_periods).min()
    smax = high.rolling(window, min_periods=min_periods).max()
    stoch_k = 100 * (close - smin) / (smax - smin)
    if fillna:
        stoch_k = stoch_k.fillna(50)

    min_periods = 0 if fillna else smooth_window
    stoch_d = stoch_k.rolling(smooth_window, min_periods=min_periods).mean()
    if fillna:
        stoch_d = stoch_d.fillna(50)

    stoch_hist = stoch_k - stoch_d
    if fillna:
        stoch_hist = stoch_hist.fillna(0)

    df_copy['stoch'] = stoch_k.round(2)
    df_copy['stoch_signal'] = stoch_d.round(2)
    df_copy['stoch_hist'] = stoch_hist.round(2)

    return df_copy[['stoch', 'stoch_signal', 'stoch_hist']]


def WilliamsR(
    df: pd.DataFrame,
    high_col: str = 'high',
    low_col: str = 'low',
    close_col: str = 'close',
    lbp: int = 14,
    fillna: bool = False,
) -> pd.DataFrame:
    """
    Williams %R

    The Williams %R is a momentum indicator that measures overbought and oversold levels.

    Inspired by: https://www.tradingview.com/script/REGZq58T-Williams-R/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the high, low, and close columns.
    - high_col (str): Name of the column containing high price data. Default is 'high'.
    - low_col (str): Name of the column containing low price data. Default is 'low'.
    - close_col (str): Name of the column containing close price data. Default is 'close'.
    - lbp (int): Lookback period. Default is 14.
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        df['williams_r'] = bta.WilliamsR(df, 'high', 'low', 'close', 14)['williams_r']

    Returns:
    - pd.DataFrame: DataFrame with 'williams_r' column.
    """
    df_copy = df.copy()

    min_periods = 0 if fillna else lbp
    highest_high = df_copy[high_col].rolling(lbp, min_periods=min_periods).max()
    lowest_low = df_copy[low_col].rolling(lbp, min_periods=min_periods).min()
    wr = -100 * (highest_high - df_copy[close_col]) / (highest_high - lowest_low)
    if fillna:
        wr = wr.fillna(-50)

    df_copy['williams_r'] = wr.round(2)
    
    return df_copy[['williams_r']]

        ----- End of momentum.py -----

        performance.py

        ----- Start of performance.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of performance.py -----

        statistics.py

        ----- Start of statistics.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *

        ----- End of statistics.py -----

        trend.py

        ----- Start of trend.py -----

# -*- coding: utf-8 -*-
from pandas import DataFrame
import math
import numpy as np
import pandas as pd
# from .bamboo_ta import *
from .volatility import *
# from .trend import SMA, EMA, LSMA, HMA, WMA
from .utility import *

def AlligatorBands(
    df: pd.DataFrame,
    column: str = 'close',
    jaw_period: int = 13,
    teeth_period: int = 8,
    lips_period: int = 5,
    jaw_shift: int = 8,
    teeth_shift: int = 5,
    lips_shift: int = 3
) -> pd.DataFrame:
    """
    Bill Williams Alligator Indicator

    The Alligator Indicator is used to identify trends and their direction in the market. It consists of three smoothed moving averages known as the Jaw, Teeth, and Lips.

    Parameters:
    - df (pandas.DataFrame): DataFrame containing the data.
    - column (str): The column name on which the Alligator is to be applied. Default is 'close'.
    - jaw_period (int): Period for the Alligator's Jaw (blue line). Default is 13.
    - teeth_period (int): Period for the Alligator's Teeth (red line). Default is 8.
    - lips_period (int): Period for the Alligator's Lips (green line). Default is 5.
    - jaw_shift (int): Number of periods to shift the Jaw line into the future. Default is 8.
    - teeth_shift (int): Number of periods to shift the Teeth line into the future. Default is 5.
    - lips_shift (int): Number of periods to shift the Lips line into the future. Default is 3.

    Call with:
        alligator_result = bta.AlligatorBands(df, 'close', 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
        df['jaw'] = alligator_result['jaw']
        df['teeth'] = alligator_result['teeth']
        df['lips'] = alligator_result['lips']

    Returns:
    - pd.DataFrame: DataFrame with 'jaw', 'teeth', and 'lips' columns.
    """
    df_copy = df.copy()

    df_copy['jaw'] = df_copy[column].rolling(window=jaw_period).mean().shift(jaw_shift)
    df_copy['teeth'] = df_copy[column].rolling(window=teeth_period).mean().shift(teeth_shift)
    df_copy['lips'] = df_copy[column].rolling(window=lips_period).mean().shift(lips_shift)

    df_copy['jaw'] = df_copy['jaw'].round(2)
    df_copy['teeth'] = df_copy['teeth'].round(2)
    df_copy['lips'] = df_copy['lips'].round(2)

    return df_copy[['jaw', 'teeth', 'lips']]


def BollingerTrend(df: pd.DataFrame, column: str = 'close', short_length: int = 20, long_length: int = 50, std_dev: float = 2.0) -> pd.DataFrame:
    """
    Bollinger Trend Indicator

    The Bollinger Trend Indicator calculates the trend based on the difference between short and long Bollinger Bands.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is 'close'.
    - short_length (int): The period for the short Bollinger Bands. Default is 20.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - std_dev (float): The standard deviation multiplier for the Bollinger Bands. Default is 2.0.

    Call with:
        df['bbtrend'] = bta.BollingerTrend(df, 'close', 20, 50, 2.0)['bbtrend']

    Returns:
    - pd.DataFrame: DataFrame with 'bbtrend' column.
    """
    df_copy = df.copy()

    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=std_dev)
    short_middle = short_bb['bb_middle']
    short_upper = short_bb['bb_upper']
    short_lower = short_bb['bb_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=std_dev)
    long_middle = long_bb['bb_middle']
    long_upper = long_bb['bb_upper']
    long_lower = long_bb['bb_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100

    # Fill NaN values that may arise from the calculation
    bbtrend = bbtrend.fillna(0)

    df_copy['bbtrend'] = bbtrend.round(2)

    return df_copy[['bbtrend']]


def bollinger_trend_fast_with_ma(
    df: pd.DataFrame,
    column: str = 'close',
    short_length: int = 10,
    long_length: int = 50,
    short_stddev: float = 1.0,
    long_stddev: float = 2.0,
    ma_type: str = 'SMA',
    ma_length: int = 14
) -> pd.DataFrame:
    """
    Bollinger Trend Indicator with Selectable Moving Average

    From: https://www.tradingview.com/script/rI3zj2j6-Bollinger-Bands-Fast-Trend-Indicator-DCD/

    This function calculates a more responsive Bollinger Trend (BBTrend) and applies a selected moving average to the BBTrend.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which BBTrend is to be calculated. Default is 'close'.
    - short_length (int): The period for the short Bollinger Bands. Default is 10.
    - long_length (int): The period for the long Bollinger Bands. Default is 50.
    - short_stddev (float): The standard deviation multiplier for the short Bollinger Bands. Default is 1.0.
    - long_stddev (float): The standard deviation multiplier for the long Bollinger Bands. Default is 2.0.
    - ma_type (str): The type of moving average to use ('SMA', 'EMA', 'LSMA', 'HMA', 'WMA'). Default is 'SMA'.
    - ma_length (int): The period for the moving average. Default is 14.

    Call with:
        result = bta.bollinger_trend_fast_with_ma(df, 'close', 10, 50, 1.0, 2.0, 'SMA', 14)
        df['bollinger_trend_fast'] = result['bbtrend']
        df['bollinger_trend_fast_ma'] = result['bbtrend_ma']

    Returns:
    - pd.DataFrame: DataFrame with 'bbtrend' and 'bbtrend_ma' columns.
    """
    df_copy = df.copy()

    # Calculate short Bollinger Bands
    short_bb = BollingerBands(df, column=column, period=short_length, std_dev=short_stddev)
    short_middle = short_bb['bb_middle']
    short_upper = short_bb['bb_upper']
    short_lower = short_bb['bb_lower']

    # Calculate long Bollinger Bands
    long_bb = BollingerBands(df, column=column, period=long_length, std_dev=long_stddev)
    long_middle = long_bb['bb_middle']
    long_upper = long_bb['bb_upper']
    long_lower = long_bb['bb_lower']

    # Calculate BBTrend
    bbtrend = (np.abs(short_lower - long_lower) - np.abs(short_upper - long_upper)) / short_middle * 100
    bbtrend = bbtrend.round(2)

    # Select and calculate the moving average
    bbtrend_df = df.assign(bbtrend=bbtrend)
    if ma_type == 'SMA':
        ma = SMA(bbtrend_df, column='bbtrend', period=ma_length)
    elif ma_type == 'EMA':
        ma = EMA(bbtrend_df, column='bbtrend', period=ma_length)
    elif ma_type == 'LSMA':
        ma = LSMA(bbtrend_df, column='bbtrend', period=ma_length)
    elif ma_type == 'HMA':
        ma = HMA(bbtrend_df, column='bbtrend', period=ma_length)
    elif ma_type == 'WMA':
        ma = WMA(bbtrend_df, column='bbtrend', period=ma_length)
    else:
        raise ValueError("Unsupported moving average type")

    # Returning as DataFrame
    result = df.copy()
    result['bbtrend'] = bbtrend.round(2)
    result['bbtrend_ma'] = ma.round(2)

    return result[['bbtrend', 'bbtrend_ma']]


def Breakouts(df: pd.DataFrame, length: int = 20) -> pd.DataFrame:
    """
    S/R Breakouts and Retests

    Makes it easy to work with Support and Resistance.
    Find Retests, Breakouts and the next levels.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', and 'close' columns.
    - length (int): Lookback period.

    Call with:
        breakout = bta.Breakouts(df, length=20)
        df['support_level'] = breakout['support_level']
        df['resistance_level'] = breakout['resistance_level']
        df['support_breakout'] = breakout['support_breakout']
        df['resistance_breakout'] = breakout['resistance_breakout']
        df['support_retest'] = breakout['support_retest']
        df['potential_support_retest'] = breakout['potential_support_retest']
        df['resistance_retest'] = breakout['resistance_retest']
        df['potential_resistance_retest'] = breakout['potential_resistance_retest']

    Returns:
    - pd.DataFrame: DataFrame with event columns populated.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    high = df_copy['high']
    low = df_copy['low']
    close = df_copy['close']

    pl = low.rolling(window=length * 2 + 1).min()
    ph = high.rolling(window=length * 2 + 1).max()
    
    s_yLoc = low.shift(length + 1).where(low.shift(length + 1) > low.shift(length - 1), low.shift(length - 1))
    r_yLoc = high.shift(length + 1).where(high.shift(length + 1) > high.shift(length - 1), high.shift(length + 1))

    cu = close < s_yLoc.shift(length)
    co = close > r_yLoc.shift(length)

    s1 = (high >= s_yLoc.shift(length)) & (close <= pl.shift(length))
    s2 = (high >= s_yLoc.shift(length)) & (close >= pl.shift(length)) & (close <= s_yLoc.shift(length))
    s3 = (high >= pl.shift(length)) & (high <= s_yLoc.shift(length))
    s4 = (high >= pl.shift(length)) & (high <= s_yLoc.shift(length)) & (close < pl.shift(length))

    r1 = (low <= r_yLoc.shift(length)) & (close >= ph.shift(length))
    r2 = (low <= r_yLoc.shift(length)) & (close <= ph.shift(length)) & (close >= r_yLoc.shift(length))
    r3 = (low <= ph.shift(length)) & (low >= r_yLoc.shift(length))
    r4 = (low <= ph.shift(length)) & (low >= r_yLoc.shift(length)) & (close > ph.shift(length))

    df_copy['support_level'] = pl.diff().where(pl.diff().notna())
    df_copy['resistance_level'] = ph.diff().where(ph.diff().notna())
    
    df_copy['support_level'] = df_copy['support_level'].combine_first(df_copy['support_level'].shift())
    df_copy['resistance_level'] = df_copy['resistance_level'].combine_first(df_copy['resistance_level'].shift())
    
    df_copy['support_breakout'] = cu
    df_copy['resistance_breakout'] = co
    df_copy['support_retest'] = (s1 | s2 | s3 | s4).astype(int)
    df_copy['potential_support_retest'] = (s1 | s2 | s3).astype(int)
    df_copy['resistance_retest'] = (r1 | r2 | r3 | r4).astype(int)
    df_copy['potential_resistance_retest'] = (r1 | r2 | r3).astype(int)
    
    return df_copy[['support_level', 'resistance_level', 'support_breakout', 'resistance_breakout', 'support_retest', 'potential_support_retest', 'resistance_retest', 'potential_resistance_retest']].round(2)


def EMA(df: pd.DataFrame, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Exponential Moving Average (EMA)

    The Exponential Moving Average gives more weight to recent prices and thus reacts more quickly to price changes than the Simple Moving Average.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which EMA is to be calculated. Default is 'close'.
    - period (int): The period over which EMA is to be calculated. Default is 21.

    Call with:
        df['ema'] = bta.EMA(df, 'close', 50)['ema']

    Returns:
    - pd.DataFrame: DataFrame with 'ema' column.
    """
    df_copy = df.copy()
    df_copy['ema'] = df_copy[column].ewm(span=period, adjust=False).mean().round(2)
    
    return df_copy[['ema']]


def HMA(df: pd.DataFrame, column: str = 'close', period: int = 9) -> pd.DataFrame:
    """
    Hull Moving Average (HMA)

    The Hull Moving Average (HMA) is an improved moving average that is responsive and has minimal lag. It involves the combination of WMA (Weighted Moving Average) with different periods.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which HMA is to be calculated. Default is 'close'.
    - period (int): The period over which HMA is to be calculated. Default is 9.

    Call with:
        df['hma'] = bta.HMA(df, 'close', 9)['hma']

    Returns:
    - pd.DataFrame: DataFrame with 'hma' column.
    """
    df_copy = df.copy()

    half_length = math.floor(period / 2)
    sqrt_length = math.floor(math.sqrt(period))

    wma_half = WMA(df_copy, column=column, period=half_length)['wma']
    wma_full = WMA(df_copy, column=column, period=period)['wma']

    h = 2 * wma_half - wma_full
    h_df = pd.DataFrame(h, columns=[column])
    hma = WMA(h_df.assign(close=h), column='close', period=sqrt_length)['wma'].round(2)

    df_copy['hma'] = hma

    return df_copy[['hma']]


def LSMA(df: pd.DataFrame, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Least Squares Moving Average (LSMA)

    LSMA uses linear regression to compute the trend of the data over a specified period. It fits a straight line to the data points using the method of least squares to depict the direction of movement.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which LSMA is to be calculated. Default is 'close'.
    - period (int): The period over which LSMA is to be calculated. Default is 21.

    Call with:
        df['lsma'] = bta.LSMA(df, 'close', 50)['lsma']

    Returns:
    - pd.DataFrame: DataFrame with 'lsma' column.
    """
    lsma_values = []

    for i in range(period - 1, len(df)):
        # Extract the most recent N df points
        subset = df.iloc[i + 1 - period:i + 1]

        # Perform linear regression to fit a line
        x = np.arange(len(subset))
        y = subset[column].values
        slope, intercept = np.polyfit(x, y, 1)

        # Calculate the LSMA value using the linear equation
        lsma = intercept + slope * (period - 1)
        lsma_values.append(lsma)

    lsma_series = pd.Series(lsma_values, index=df.index[period - 1:]).round(2)

    df_copy = df.copy()
    df_copy['lsma'] = lsma_series

    return df_copy[['lsma']]


def PercentPriceChannel(df: pd.DataFrame, period: int = 20, mult: int = 2) -> pd.DataFrame:
    """
    Percent Change Channel (PCC)
    PCC is like KC unless it uses percentage changes in price to set channel distance.
    https://www.tradingview.com/script/6wwAWXA1-MA-Streak-Change-Channel/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing the data.
    - period (int): Period for the ZEMA calculation. Default is 20.
    - mult (int): Multiplier for the range. Default is 2.

    Call with:
        pcc_result = bta.PercentPriceChannel(df, period=20, mult=2)
        df['pcc_upper'] = pcc_result['pcc_upper']
        df['pcc_rangema'] = pcc_result['pcc_rangema']
        df['pcc_lower'] = pcc_result['pcc_lower']

    Returns:
    - pd.DataFrame: DataFrame with 'pcc_upper', 'pcc_rangema', and 'pcc_lower' columns.
    """
    df_copy = df.copy()

    df_copy['previous_close'] = df_copy['close'].shift()
    df_copy['close_change'] = ((df_copy['close'] - df_copy['previous_close']) / df_copy['previous_close'] * 100).round(2)
    df_copy['high_change'] = ((df_copy['high'] - df_copy['close']) / df_copy['close'] * 100).round(2)
    df_copy['low_change'] = ((df_copy['low'] - df_copy['close']) / df_copy['close'] * 100).round(2)
    df_copy['delta'] = (df_copy['high_change'] - df_copy['low_change']).round(2)

    mid = ZEMA(df_copy, column='close_change', period=period)['zema']
    rangema = ZEMA(df_copy, column='delta', period=period)['zema']

    df_copy['pcc_upper'] = (mid + rangema * mult).round(2)
    df_copy['pcc_rangema'] = rangema.round(2)
    df_copy['pcc_lower'] = (mid - rangema * mult).round(2)

    return df_copy[['pcc_upper', 'pcc_rangema', 'pcc_lower']]


def PriceChannel(df: pd.DataFrame, period: int = 20) -> pd.DataFrame:
    """
    Percent Price Channel (PPC)
    
    The Price Channel % PC indicator calculates the percent change of the price channel.
    It calculates the highest high and lowest low of the trailing number of bars specified by the input period. The price channel calculates the highest high and lowest low of the trailing number of bars specified by the input Length. When a market moves above the upper band, it is a sign of market strength. Conversely, when a market moves below the lower band, it is a sign of market weakness. A sustained move above or below the channel lines may indicate a significant breakout.

    The percent_p column in the PercentPriceChannel function represents the percentage position of the current closing price within the price channel defined by the highest high and lowest low over a specified period. It shows where the current closing price stands relative to the recent highest and lowest prices.

    Value Range:

    The percent_p values range from 0 to 100.
    A value of 0 indicates that the closing price is at the lowest low of the specified period.
    A value of 100 indicates that the closing price is at the highest high of the specified period.

    Trend Strength and Position:

    Above 50%: When percent_p is above 50%, the closing price is closer to the highest high. This suggests that the price is relatively strong and trading in the upper part of the range.
    Below 50%: When percent_p is below 50%, the closing price is closer to the lowest low. This suggests that the price is relatively weak and trading in the lower part of the range.

    Overbought and Oversold Conditions:

    Near 100%: When percent_p approaches 100%, it indicates that the price is near its recent peak, which might suggest an overbought condition.
    Near 0%: When percent_p approaches 0%, it indicates that the price is near its recent bottom, which might suggest an oversold condition.

    Breakout Indications:

    Sustained High Values: A sustained percent_p value above 80% could indicate strong upward momentum and a potential bullish breakout.
    Sustained Low Values: A sustained percent_p value below 20% could indicate strong downward momentum and a potential bearish breakout.

    Inspired by: https://www.tradingview.com/script/bQ2sg8b7-Price-Channel/
    and: https://help.tradestation.com/10_00/eng/tradestationhelp/elanalysis/indicator/price_channel__percent_pc_indicator_.htm

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing the data.
    - period (int): Period for the highest high and lowest low calculation. Default is 20.

    Call with:
        ppc_result = PriceChannel(df, period=20)
        df['ppc_upper'] = ppc_result['ppc_upper']
        df['ppc_mid'] = ppc_result['ppc_mid']
        df['ppc_lower'] = ppc_result['ppc_lower']
        df['percent_p'] = ppc_result['percent_p']

    Returns:
    - pd.DataFrame: DataFrame with 'ppc_upper', 'ppc_mid', 'ppc_lower', and 'percent_p' columns.
    """
    df_copy = df.copy()

    df_copy['highest_high'] = df_copy['high'].rolling(window=period, min_periods=1).max()
    df_copy['lowest_low'] = df_copy['low'].rolling(window=period, min_periods=1).min()

    df_copy['ppc_upper'] = df_copy['highest_high'].round(2)
    df_copy['ppc_lower'] = df_copy['lowest_low'].round(2)
    df_copy['ppc_mid'] = ((df_copy['ppc_upper'] + df_copy['ppc_lower']) / 2).round(2)

    df_copy['percent_p'] = ((df_copy['close'] - df_copy['ppc_lower']) / (df_copy['ppc_upper'] - df_copy['ppc_lower']) * 100).round(2)

    return df_copy[['ppc_upper', 'ppc_mid', 'ppc_lower', 'percent_p']]


def RMA(df: pd.DataFrame, column: str = 'close', period: int = 14) -> pd.DataFrame:
    """
    Rolling Moving Average (RMA) calculation.

    The RMA function calculates the Rolling Moving Average (RMA) of a specified column in a DataFrame over a given period. It uses an exponential moving average (EMA) calculation with a specified smoothing factor (alpha) and returns a DataFrame containing the RMA values rounded to two decimal places. This function allows for flexible moving average calculations based on any column in the input DataFrame

    Inspired by: https://www.tradingview.com/script/5BUyR2JA-rolling-moving-average/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the specified column.
    - column (str): The column on which RMA is to be calculated.
    - period (int): The period over which RMA is to be calculated.

    Call with:
        df['rma'] = bta.RMA(df, 'close', 14)['rma']

    Returns:
    - pd.DataFrame: DataFrame with 'rma' column.
    """
    df_copy = df.copy()
    df_copy['rma'] = df_copy[column].ewm(alpha=1/period, adjust=False).mean().round(2)

    return df_copy[['rma']]


def SMA(df: pd.DataFrame, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Simple Moving Average (SMA)

    The Simple Moving Average is the unweighted mean of the previous 'period' data points.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which SMA is to be calculated. Default is 'close'.
    - period (int): The period over which SMA is to be calculated. Default is 21.

    Call with:
        df['sma'] = bta.SMA(df, 'close', 50)['sma']

    Returns:
    - pd.DataFrame: DataFrame with 'sma' column.
    """
    df_copy = df.copy()
    df_copy['sma'] = df_copy[column].rolling(window=period).mean().round(2)

    return df_copy[['sma']]


def SSLChannels(df: pd.DataFrame, length: int = 10, mode: str = 'sma') -> pd.DataFrame:
    """
    SSL Channels

    SSL Channels is an indicator based on the concept of using different moving averages to identify trends. This function calculates the SSL Down and SSL Up series.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing the data.
    - length (int): Period for the SMA calculation. Default is 10.
    - mode (str): Type of moving average to use. Currently only 'sma' is supported.

    Call with:
        ssl_result = bta.SSLChannels(df, length=10, mode='sma')
        df['ssl_down'] = ssl_result['ssl_down']
        df['ssl_up'] = ssl_result['ssl_up']

    Returns:
    - pd.DataFrame: DataFrame with 'ssl_down' and 'ssl_up' columns.
    """
    df_copy = df.copy()

    if mode not in ('sma'):
        raise ValueError(f"Mode {mode} not supported yet")
    
    df_copy['sma_high'] = df_copy['high'].rolling(length).mean()
    df_copy['sma_low'] = df_copy['low'].rolling(length).mean()
    df_copy['hlv'] = np.where(df_copy['close'] > df_copy['sma_high'], 1,
                              np.where(df_copy['close'] < df_copy['sma_low'], -1, np.NAN))
    df_copy['hlv'] = df_copy['hlv'].ffill()
    df_copy['ssl_down'] = np.where(df_copy['hlv'] < 0, df_copy['sma_high'], df_copy['sma_low'])
    df_copy['ssl_up'] = np.where(df_copy['hlv'] < 0, df_copy['sma_low'], df_copy['sma_high'])

    df_copy['ssl_down'] = df_copy['ssl_down'].round(2)
    df_copy['ssl_up'] = df_copy['ssl_up'].round(2)

    return df_copy[['ssl_down', 'ssl_up']]


def SSLChannelsATR(df: pd.DataFrame, column: str = 'close', length: int = 21, atr_period: int = 14) -> pd.DataFrame:
    """
    SSL Channels with ATR

    The SSLChannelsATR function calculates the SSL (Safe and Secure Levels) channels using the Average True Range (ATR) to adjust the Simple Moving Averages (SMA) of the high and low prices over a specified period. It determines the trend direction based on the comparison of a chosen price column with these adjusted SMAs and generates the SSL ATR Down and Up levels accordingly. This indicator helps identify potential trend reversals and continuations by providing dynamic support and resistance levels.

    Inspired by: https://www.tradingview.com/script/SKHqWzql-SSL-ATR-channel/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing the data.
    - length (int): Period for the SMA calculation. Default is 21.
    - atr_period (int): Period for the ATR calculation. Default is 14.
    - column (str): The column to use for the moving average calculations. Default is 'close'.

    Call with:
        ssl_result = bta.SSLChannelsATR(df, column='close', length=14, atr_period=7)
        df['ssl_atr_down'] = ssl_result['ssl_atr_down']
        df['ssl_atr_up'] = ssl_result['ssl_atr_up']

    Returns:
    - pd.DataFrame: DataFrame with 'ssl_atr_down' and 'ssl_atr_up' columns.
    """
    def calculate_atr(df, period):
        high_low = df['high'] - df['low']
        high_close = np.abs(df['high'] - df['close'].shift())
        low_close = np.abs(df['low'] - df['close'].shift())
        tr = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        atr = tr.rolling(window=period, min_periods=1).mean()
        return atr

    df_copy = df.copy()

    df_copy['atr'] = calculate_atr(df_copy, atr_period)
    df_copy['sma_high'] = (df_copy['high'].rolling(length).mean() + df_copy['atr']).round(2)
    df_copy['sma_low'] = (df_copy['low'].rolling(length).mean() - df_copy['atr']).round(2)
    df_copy['hlv'] = np.where(df_copy[column] > df_copy['sma_high'], 1, 
                              np.where(df_copy[column] < df_copy['sma_low'], -1, np.nan))
    df_copy['hlv'] = df_copy['hlv'].ffill()
    df_copy['ssl_atr_down'] = np.where(df_copy['hlv'] < 0, df_copy['sma_high'], df_copy['sma_low'])
    df_copy['ssl_atr_up'] = np.where(df_copy['hlv'] < 0, df_copy['sma_low'], df_copy['sma_high'])

    df_copy['ssl_atr_down'] = df_copy['ssl_atr_down'].round(2)
    df_copy['ssl_atr_up'] = df_copy['ssl_atr_up'].round(2)

    return df_copy[['ssl_atr_down', 'ssl_atr_up']]


def T3(df: pd.DataFrame, length: int = 5) -> pd.DataFrame:
    """
    T3 Average 
    
    Inspired by: https://www.tradingview.com/script/qzoC9H1I-T3-Average/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame containing the data.
    - length (int): Period for the EMA calculation. Default is 5.

    Call with:
        df['t3_average'] = bta.T3(df, length=5)['t3_average']

    Returns:
    - pd.DataFrame: DataFrame with 't3_average' column.
    """
    df_copy = df.copy()

    df_copy['xe1'] = EMA(df_copy, column='close', period=length)['ema']
    df_copy['xe2'] = EMA(df_copy, column='xe1', period=length)['ema']
    df_copy['xe3'] = EMA(df_copy, column='xe2', period=length)['ema']
    df_copy['xe4'] = EMA(df_copy, column='xe3', period=length)['ema']
    df_copy['xe5'] = EMA(df_copy, column='xe4', period=length)['ema']
    df_copy['xe6'] = EMA(df_copy, column='xe5', period=length)['ema']
    
    b = 0.7
    c1 = -b*b*b
    c2 = 3*b*b+3*b*b*b
    c3 = -6*b*b-3*b-3*b*b*b
    c4 = 1+3*b+b*b*b+3*b*b
    
    df_copy['t3_average'] = (c1 * df_copy['xe6'] + 
                             c2 * df_copy['xe5'] + 
                             c3 * df_copy['xe4'] + 
                             c4 * df_copy['xe3']).round(2)
    
    return df_copy[['t3_average']]


def WMA(df: pd.DataFrame, column: str = 'close', period: int = 10) -> pd.DataFrame:
    """
    Weighted Moving Average (WMA)
    
    The Weighted Moving Average (WMA) gives more weight to recent data points and less weight to older data points.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame.
    - column (str): The column to calculate the WMA on.
    - period (int): The period for the WMA calculation.

    Call with:
        df['wma'] = bta.WMA(df, 'close', 10)['wma']
    
    Returns:
    - pd.DataFrame: DataFrame with 'wma' column.
    """
    df_copy = df.copy()
    weights = pd.Series(range(1, period + 1))
    df_copy['wma'] = df_copy[column].rolling(period).apply(lambda prices: (prices * weights).sum() / weights.sum(), raw=True).round(2)
    
    return df_copy[['wma']]


def ZEMA(df: pd.DataFrame, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Zero Lag Exponential Moving Average (ZEMA)

    The Zero Lag Exponential Moving Average (ZEMA) is an improved version of the Exponential Moving Average (EMA) that reduces lag by incorporating a zero lag component.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which ZEMA is to be calculated. Default is 'close'.
    - period (int): The period over which ZEMA is to be calculated. Default is 21.

    Call with:
        df['zema'] = bta.ZEMA(df, 'close', 21)['zema']

    Returns:
    - pd.DataFrame: DataFrame with 'zema' column.
    """
    df_copy = df.copy()
    ema1 = df_copy[column].ewm(span=period, adjust=False).mean()
    ema2 = ema1.ewm(span=period, adjust=False).mean()
    df_copy['zema'] = (2 * ema1 - ema2).round(2)

    return df_copy[['zema']]


def ZLEMA(df: pd.DataFrame, column: str = 'close', period: int = 21) -> pd.DataFrame:
    """
    Zero Lag Exponential Moving Average (ZLEMA)

    Inspired by: https://www.tradingview.com/script/Oxizu1k7-Zero-Lag-Exponential-Moving-Average/

    Call with:
        df['zlema'] = bta.ZLEMA(df, 'close', 21)['zlema']

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain at least the column specified.
    - column (str): The column on which ZLEMA is to be calculated. Default is 'close'.
    - period (int): The period over which ZLEMA is to be calculated. Default is 21.

    Returns:
    - pd.DataFrame: DataFrame with 'zlema' column.

    Description:
    Zero Lag Exponential Moving Average (ZLEMA) is an EMA that adjusts for lag, making it more responsive to recent price changes. It uses lagged data differences to adjust the EMA calculation, thereby supposedly removing the inherent lag of EMA.
    """
    lag = int((period - 1) / 2)

    # Calculating the adjusted data series
    ema_data = df[column] + (df[column] - df[column].shift(lag))

    # Computing the EMA of the adjusted data series
    zlema = ema_data.ewm(span=period, adjust=False).mean().round(2)

    df_copy = df.copy()
    df_copy['zlema'] = zlema

    return df_copy[['zlema']]

        ----- End of trend.py -----

        utility.py

        ----- Start of utility.py -----

# -*- coding: utf-8 -*-
import math
import numpy as np
import pandas as pd
from .bamboo_ta import *
from scipy.signal import argrelextrema


def Calculate_Exhaustion_Lengths(df):
    """
    Calculate the average length of peaks and valleys to adjust the exhaustion bands dynamically
    
    Parameters:
    - df (pandas.DataFrame): Input DataFrame.

    Call with:
        maj_len, min_len = Calculate_Exhaustion_Lengths(df)
        df['maj_len'] = maj_len
        df['min_len'] = min_len

    Returns:
    - int, int: Average peak distance and average valley distance.
    """
    high_indices = argrelextrema(df['high'].to_numpy(), np.greater)[0]
    low_indices = argrelextrema(df['low'].to_numpy(), np.less)[0]

    if len(high_indices) < 2 or len(low_indices) < 2:
        return 0, 0

    avg_peak_distance = np.mean(np.diff(high_indices))
    std_peak_distance = np.std(np.diff(high_indices))
    avg_valley_distance = np.mean(np.diff(low_indices))
    std_valley_distance = np.std(np.diff(low_indices))

    maj_len = int(avg_peak_distance + std_peak_distance)
    min_len = int(avg_valley_distance + std_valley_distance)

    return maj_len, min_len


def Calculate_Exhaustion_Candles(df, window=1, multiplier=1):
    """
    Calculate the average consecutive length of ups and downs to adjust the exhaustion bands dynamically
    
    Parameters:
    - df (pandas.DataFrame): Input DataFrame.
    - window (int): Lookback window for calculation.
    - multiplier (int or np.ndarray): Scalar or array of multipliers.

    Call with:
        maj_qual, min_qual = Calculate_Exhaustion_Candles(df, window, multiplier)
        df['maj_qual'] = maj_qual
        df['min_qual'] = min_qual

    Returns:
    - np.ndarray, np.ndarray: Arrays of major and minor quality values.
    """
    consecutive_diff = np.sign(df['close'].diff())
    maj_qual = np.zeros(len(df))
    min_qual = np.zeros(len(df))

    # Ensure multiplier is an array
    if isinstance(multiplier, (int, float)):
        multiplier = np.full(len(df), multiplier)
    elif isinstance(multiplier, np.ndarray) and multiplier.shape[0] != len(df):
        raise ValueError("Length of multiplier array must match the length of the DataFrame")

    for i in range(len(df)):
        idx_range = consecutive_diff[i - window + 1:i + 1] if i >= window else consecutive_diff[:i + 1]
        avg_consecutive = Consecutive_Count(idx_range)
        if isinstance(avg_consecutive, np.ndarray):
            avg_consecutive = avg_consecutive.item()
        maj_qual[i] = int(avg_consecutive * (3 * multiplier[i])) if not np.isnan(avg_consecutive) else 0
        min_qual[i] = int(avg_consecutive * (3 * multiplier[i])) if not np.isnan(avg_consecutive) else 0

    return maj_qual, min_qual

def Consecutive_Count(consecutive_diff):
    """
    Calculate the average consecutive count of non-zero differences
    
    Parameters:
    - consecutive_diff (np.ndarray): Array of consecutive differences.

    Returns:
    - float: Average consecutive count.
    """
    non_zero_diff = np.where(consecutive_diff != 0)[0]
    if len(non_zero_diff) < 2:
        return 0
    return np.mean(np.abs(np.diff(non_zero_diff)))


def Linear_Decay(start: float, end: float, start_time: int, end_time: int, trade_time: int) -> float:
    """
    Simple linear decay function. Decays from start to end after end_time minutes (starts after start_time minutes)

    Parameters:
    - start (float): Starting value.
    - end (float): Ending value.
    - start_time (int): Start time in minutes.
    - end_time (int): End time in minutes.
    - trade_time (int): Current trade time in minutes.

    Call with:
        decayed_value = Linear_Decay(start, end, start_time, end_time, trade_time)

    Returns:
    - float: Decayed value.
    """
    time = max(0, trade_time - start_time)
    rate = (start - end) / (end_time - start_time)
    return max(end, start - (rate * time))


def Linear_Growth(start: float, end: float, start_time: int, end_time: int, trade_time: int) -> float:
    """
    Simple linear growth function. Grows from start to end after end_time minutes (starts after start_time minutes)

    Parameters:
    - start (float): Starting value.
    - end (float): Ending value.
    - start_time (int): Start time in minutes.
    - end_time (int): End time in minutes.
    - trade_time (int): Current trade time in minutes.

    Call with:
        grown_value = Linear_Growth(start, end, start_time, end_time, trade_time)

    Returns:
    - float: Grown value.
    """
    time = max(0, trade_time - start_time)
    rate = (end - start) / (end_time - start_time)
    return min(end, start + (rate * time))


def populate_leledc_major_minor(df, maj_qual, min_qual, maj_len, min_len):
    """
    Populate Leledc Major and Minor columns

    Parameters:
    - df (pandas.DataFrame): Input DataFrame.
    - maj_qual (np.ndarray): Array of major quality values.
    - min_qual (np.ndarray): Array of minor quality values.
    - maj_len (int): Major length value.
    - min_len (int): Minor length value.

    Call with:
        leledc_major_minor = populate_leledc_major_minor(df, maj_qual, min_qual, maj_len, min_len)

    Returns:
    - pd.DataFrame: DataFrame with populated columns.
    """
    df_copy = df.copy()
    bindex_maj, sindex_maj, trend_maj = 0, 0, 0
    bindex_min, sindex_min = 0, 0

    df_copy['leledc_major'] = np.nan
    df_copy['leledc_minor'] = 0

    for i in range(1, len(df_copy)):
        close = df_copy['close'][i]
        short_length = i if i < 4 else 4

        if close > df_copy['close'][i - short_length]:
            bindex_maj += 1
            bindex_min += 1
        elif close < df_copy['close'][i - short_length]:
            sindex_maj += 1
            sindex_min += 1

        update_major = False
        if bindex_maj > maj_qual[i] and close < df_copy['open'][i] and df_copy['high'][i] >= df_copy['high'][i - maj_len:i].max():
            bindex_maj, trend_maj, update_major = 0, 1, True
        elif sindex_maj > maj_qual[i] and close > df_copy['open'][i] and df_copy['low'][i] <= df_copy['low'][i - maj_len:i].min():
            sindex_maj, trend_maj, update_major = 0, -1, True

        df_copy.at[i, 'leledc_major'] = trend_maj if update_major else np.nan if trend_maj == 0 else trend_maj
        if bindex_min > min_qual[i] and close < df_copy['open'][i] and df_copy['high'][i] >= df_copy['high'][i - min_len:i].max():
            bindex_min = 0
            df_copy.at[i, 'leledc_minor'] = -1
        elif sindex_min > min_qual[i] and close > df_copy['open'][i] and df_copy['low'][i] <= df_copy['low'][i - min_len:i].min():
            sindex_min = 0
            df_copy.at[i, 'leledc_minor'] = 1
        else:
            df_copy.at[i, 'leledc_minor'] = 0

    return df_copy


def SameLength(bigger, shorter):
    """
    Ensures the shorter array has the same length as the bigger array by padding with NaN values.

    Parameters:
    - bigger (np.ndarray): The array with the larger size.
    - shorter (np.ndarray): The array with the smaller size.

    Call with:
        padded_array = SameLength(bigger, shorter)

    Returns:
    - np.ndarray: The shorter array padded with NaN values to match the size of the bigger array.
    """
    return np.concatenate((np.full((bigger.shape[0] - shorter.shape[0]), np.nan), shorter))


def ZScore(series, window=500):
    """
    Calculate the z-score of a series.

    Parameters:
    - series (pd.Series): Input series.
    - window (int): Lookback window for mean and standard deviation calculation.

    Call with:
        zscore = ZScore(series)
        df['zscore'] = zscore

    Returns:
    - pd.Series: Z-score series.
    """
    mean = series.rolling(window=window, min_periods=1).mean()
    std = series.rolling(window=window, min_periods=1).std(ddof=0)
    zscore = (series - mean) / std
    zscore = zscore.fillna(0)  # Fill NaN values with 0 to avoid issues with calculations

    return zscore


class IndicatorMixin:
    """Util mixin indicator class"""

    _fillna = False

    def _check_fillna(self, series: pd.Series, value: int = 0) -> pd.Series:
        """Check if fillna flag is True.

        Parameters:
        - series (pandas.Series): Calculated indicator series.
        - value (int): Value to fill gaps; if -1 fill values using 'backfill' mode.

        Returns:
        - pd.Series: New feature generated.
        """
        if self._fillna:
            series_output = series.copy(deep=False)
            series_output = series_output.replace([np.inf, -np.inf], np.nan)
            if isinstance(value, int) and value == -1:
                series = series_output.ffill().bfill()
            else:
                series = series_output.ffill().fillna(value)
        return series

    @staticmethod
    def _true_range(high: pd.Series, low: pd.Series, prev_close: pd.Series) -> pd.Series:
        tr1 = high - low
        tr2 = (high - prev_close).abs()
        tr3 = (low - prev_close).abs()
        true_range = pd.DataFrame(data={"tr1": tr1, "tr2": tr2, "tr3": tr3}).max(axis=1)
        return true_range


def dropna(df: pd.DataFrame) -> pd.DataFrame:
    """
    Drop rows with 'NaN' values

    Parameters:
    - df (pandas.DataFrame): Input DataFrame.

    Call with:
        dropna = dropna(df)

    Returns:
    - pd.DataFrame: DataFrame without NaN values.
    """
    df = df.copy()
    number_cols = df.select_dtypes(include=np.number).columns.tolist()
    df[number_cols] = df[number_cols][df[number_cols] < math.exp(709)]  # big number
    df[number_cols] = df[number_cols][df[number_cols] != 0.0]
    df = df.dropna()
    return df


def _sma(series, periods: int, fillna: bool = False):
    """
    Simple Moving Average (SMA)

    Parameters:
    - series (pd.Series): Input series.
    - periods (int): Period for SMA calculation.
    - fillna (bool): If True, fill NaN values. Default is False.

    Call with:
        sma = _sma(series, periods)
        df['sma'] = sma

    Returns:
    - pd.Series: Series of SMA values.
    """
    min_periods = 0 if fillna else periods
    return series.rolling(window=periods, min_periods=min_periods).mean()


def _ema(series, periods: int, fillna: bool = False):
    """
    Exponential Moving Average (EMA)

    Parameters:
    - series (pd.Series): Input series.
    - periods (int): Period for EMA calculation.
    - fillna (bool): If True, fill NaN values. Default is False.

    Call with:
        ema = _ema(series, periods)
        df['ema'] = ema

    Returns:
    - pd.Series: Series of EMA values.
    """
    min_periods = 0 if fillna else periods
    return series.ewm(span=periods, min_periods=min_periods, adjust=False).mean()

def STDEV(series, period):
    """
    Calculate the standard deviation over a specified period.

    Parameters:
    - series (pd.Series): The data series to calculate the standard deviation for.
    - period (int): The period over which to calculate the standard deviation.

    Returns:
    - pd.Series: The standard deviation of the series.
    """
    return series.rolling(window=period).std()

def get_min_max(series1: pd.Series, series2: pd.Series, function: str = "min"):
    """
    Find min or max value between two lists for each index

    Parameters:
    - series1 (pd.Series): First input series.
    - series2 (pd.Series): Second input series.
    - function (str): Function to apply ("min" or "max"). Default is "min".

    Call with:
        min_max_series = get_min_max(series1, series2, function)
        df['min_max'] = min_max_series

    Returns:
    - pd.Series: Series with min or max values for each index.
    """
    series1 = np.array(series1)
    series2 = np.array(series2)
    if function == "min":
        output = np.amin([series1, series2], axis=0)
    elif function == "max":
        output = np.amax([series1, series2], axis=0)
    else:
        raise ValueError('"function" variable value should be "min" or "max"')

    return pd.Series(output)


def Daily_Return(df, column="close", fillna=False):
    """
    Daily Return (DR)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the specified column.
    - column (str): The column on which the daily return is to be calculated. Default is "close".
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        dr = Daily_Return(df)
        df['daily_return'] = dr

    Returns:
    - pd.Series: Series of daily return values.
    """
    df_copy = df.copy()
    df_copy['d_ret'] = (df_copy[column] / df_copy[column].shift(1)) - 1
    df_copy['d_ret'] *= 100
    if fillna:
        df_copy['d_ret'] = df_copy['d_ret'].fillna(0)
    return df_copy['d_ret'].rename("d_ret")


def Daily_Log_Return(df, column="close", fillna=False):
    """
    Daily Log Return (DLR)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the specified column.
    - column (str): The column on which the daily log return is to be calculated. Default is "close".
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        dlr = Daily_Log_Return(df)
        df['daily_log_return'] = dlr

    Returns:
    - pd.Series: Series of daily log return values.
    """
    df_copy = df.copy()
    df_copy['d_logret'] = pd.Series(np.log(df_copy[column])).diff()
    df_copy['d_logret'] *= 100
    if fillna:
        df_copy['d_logret'] = df_copy['d_logret'].fillna(0)
    return df_copy['d_logret'].rename("d_logret")


def Cumulative_Return(df, column="close", fillna=False):
    """
    Cumulative Return (CR)

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain the specified column.
    - column (str): The column on which the cumulative return is to be calculated. Default is "close".
    - fillna (bool): If True, fill nan values. Default is False.

    Call with:
        cr = Cumulative_Return(df)
        df['cumulative_return'] = cr

    Returns:
    - pd.Series: Series of cumulative return values.
    """
    df_copy = df.copy()
    df_copy['cum_ret'] = (df_copy[column] / df_copy[column].iloc[0]) - 1
    df_copy['cum_ret'] *= 100
    if fillna:
        df_copy['cum_ret'] = df_copy['cum_ret'].fillna(-1)
    return df_copy['cum_ret'].rename("cum_ret")

        ----- End of utility.py -----

        volatility.py

        ----- Start of volatility.py -----

# -*- coding: utf-8 -*-
# volatility.py
import numpy as np
import pandas as pd


def AverageTrueRange(df: pd.DataFrame, period: int = 14) -> pd.DataFrame:
    """
    Average True Range (ATR)

    The Average True Range (ATR), smoothed by the Moving Average, is a measure of volatility. It was introduced by Welles Wilder in his book 'New Concepts in Technical Trading Systems'.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain columns 'high', 'low', and 'close'.
    - period (int): Period for the ATR calculation. Default is 14.

    Call with:
        df['atr'] = bta.AverageTrueRange(df, 14)['atr']

    Returns:
    - pd.DataFrame: DataFrame with 'atr' column.
    """
    df_copy = df.copy()
    df_copy['high_low'] = df_copy['high'] - df_copy['low']
    df_copy['high_close'] = (df_copy['high'] - df_copy['close'].shift()).abs()
    df_copy['low_close'] = (df_copy['low'] - df_copy['close'].shift()).abs()
    df_copy['true_range'] = df_copy[['high_low', 'high_close', 'low_close']].max(axis=1)
    df_copy['atr'] = df_copy['true_range'].rolling(window=period, min_periods=1).mean().round(2)

    return df_copy[['atr']]


def BollingerBands(df: pd.DataFrame, column: str = 'close', period: int = 20, std_dev: float = 2.0, ddof: int = 0) -> pd.DataFrame:
    """
    Bollinger Bands (BBANDS)

    Bollinger Bands are a type of statistical chart characterizing the prices and volatility over time of a financial instrument or commodity.

    Parameters:
    - df (pandas.DataFrame): DataFrame containing the data.
    - column (str): The column name on which the BBANDS is to be applied. Default is 'close'.
    - period (int): Look-back period to compute the moving average. Default is 20.
    - std_dev (float): Number of standard deviations to compute the upper and lower bands. Default is 2.0.
    - ddof (int): Degrees of Freedom to use in standard deviation calculation. Default is 0.

    Call with:
        bb_result = bta.BollingerBands(df, 'close', 20, 2, 0)
        df['bb_upper'] = bb_result['bb_upper']
        df['bb_middle'] = bb_result['bb_middle']
        df['bb_lower'] = bb_result['bb_lower']

    Returns:
    - pd.DataFrame: DataFrame with 'bb_upper', 'bb_middle', 'bb_lower' columns.
    """
    df_copy = df.copy()

    # Calculate middle band (SMA)
    sma = df_copy[column].rolling(window=period).mean()

    # Calculate standard deviation of the specified column
    rolling_std = df_copy[column].rolling(window=period).std(ddof=ddof)

    # Calculate upper and lower bands
    df_copy['bb_upper'] = (sma + (rolling_std * std_dev)).round(2)
    df_copy['bb_middle'] = sma.round(2)
    df_copy['bb_lower'] = (sma - (rolling_std * std_dev)).round(2)

    return df_copy[['bb_upper', 'bb_middle', 'bb_lower']]


def TrueRange(df: pd.DataFrame) -> pd.DataFrame:
    """
    Calculate True Range (TR)

    The True Range indicator measures market volatility. True Range is defined as the greatest of the following:
    - The current high minus the current low
    - The absolute value of the current high minus the previous close
    - The absolute value of the current low minus the previous close

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', and 'close' columns.

    Call with:
        df['true_range'] = bta.TrueRange(df)['true_range']

    Returns:
    - pd.DataFrame: DataFrame with 'true_range' column.
    """
    df_copy = df.copy()
    prev_close = df_copy['close'].shift()
    df_copy['true_range'] = pd.concat(
        [
            df_copy['high'] - df_copy['low'],
            (df_copy['high'] - prev_close).abs(),
            (df_copy['low'] - prev_close).abs()
        ], axis=1
    ).max(axis=1).round(2)

    return df_copy[['true_range']]

'''
TODO:
KeltnerChannel (+ width)
DonchianChannel (+ width)
Ulcer Index

    https://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:ulcer_index

Bollingerbands width and more

'''
        ----- End of volatility.py -----

        volume.py

        ----- Start of volume.py -----

# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
from .bamboo_ta import *
from .trend import *


def AccumulationDistributionIndex(df: pd.DataFrame, fillna: bool = False) -> pd.DataFrame:
    """
    Accumulation/Distribution Index (ADI)

    Acts as a leading indicator of price movements.

    Inspired by: https://www.tradingview.com/script/uRMAN1ho-ADL-Accumulation-Distribution-Line-UTS/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', 'close', and 'volume' columns.
    - fillna (bool): if True, fill nan values.

    Call with:
        df['adi'] = bta.accumulation_distribution_index(df, fillna=True)['adi']

    Returns:
    - pd.DataFrame: DataFrame with 'adi' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate the ADI values
    clv = ((df_copy['close'] - df_copy['low']) - (df_copy['high'] - df_copy['close'])) / (df_copy['high'] - df_copy['low'])
    clv = clv.fillna(0.0)  # float division by zero
    adi = clv * df_copy['volume']
    adi = adi.cumsum()
    if fillna:
        adi = adi.fillna(0)

    df_copy['adi'] = adi.round(2)

    return df_copy[['adi']]


def ChaikinMoneyFlow(df: pd.DataFrame, window: int = 20, fillna: bool = False) -> pd.DataFrame:
    """
    Chaikin Money Flow (CMF)

    Measures the amount of Money Flow Volume over a specific period.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', 'close', and 'volume' columns.
    - window (int): n period. Default is 20.
    - fillna (bool): if True, fill nan values.

    Call with:
        df['cmf'] = bta.ChaikinMoneyFlow(df, window=20, fillna=True)['cmf']

    Returns:
    - pd.DataFrame: DataFrame with 'cmf' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate the CMF values
    mfv = ((df_copy['close'] - df_copy['low']) - (df_copy['high'] - df_copy['close'])) / (df_copy['high'] - df_copy['low'])
    mfv = mfv.fillna(0.0)  # float division by zero
    mfv *= df_copy['volume']
    min_periods = 0 if fillna else window
    cmf = mfv.rolling(window, min_periods=min_periods).sum() / df_copy['volume'].rolling(window, min_periods=min_periods).sum()
    if fillna:
        cmf = cmf.fillna(0)

    df_copy['cmf'] = cmf.round(2)

    return df_copy[['cmf']]


def EaseOfMovement(df: pd.DataFrame, eom_length: int = 14, seom_length: int = 14, fillna: bool = False) -> pd.DataFrame:
    """
    Ease of Movement (EoM, EMV) and Signal Ease of Movement (SMA of EoM)

    Relates an asset's price change to its volume and is useful for assessing trend strength.
    The SMA of the EoM serves as a signal line for the indicator.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', and 'volume' columns.
    - eom_length (int): n period for the EoM calculation. Default is 14.
    - seom_length (int): n period for the SMA of EoM calculation. Default is 14.
    - fillna (bool): if True, fill nan values.

    Call with:
        eom_df = bta.EaseOfMovement(df, eom_length=14, seom_length=14, fillna=True)
        df['eom'] = eom_df['eom']
        df['eom_ma'] = eom_df['eom_ma']

    Returns:
    - pd.DataFrame: DataFrame with 'eom' and 'seom' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate the Ease of Movement (EoM) values
    emv = ((df_copy['high'].diff(1) + df_copy['low'].diff(1)) * (df_copy['high'] - df_copy['low'])) / (2 * df_copy['volume'])
    emv *= 100000000
    if fillna:
        emv = emv.fillna(0)

    df_copy['eom'] = emv.round(2) / 100000

    # Calculate the Signal Ease of Movement (SMA of EoM)
    min_periods = 0 if fillna else seom_length
    sma_emv = df_copy['eom'].rolling(seom_length, min_periods=min_periods).mean()
    if fillna:
        sma_emv = sma_emv.fillna(0)

    df_copy['seom'] = sma_emv.round(2) * 10

    return df_copy[['eom', 'seom']]


def ForceIndex(df: pd.DataFrame, window: int = 13, fillna: bool = False) -> pd.DataFrame:
    """
    Force Index (FI)

    Illustrates how strong the actual buying or selling pressure is.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - window (int): n period. Default is 13.
    - fillna (bool): if True, fill nan values.

    Call with:
        df['fi'] = bta.ForceIndex(df, window=13, fillna=True)['fi']

    Returns:
    - pd.DataFrame: DataFrame with 'fi' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate the Force Index values
    fi = (df_copy['close'] - df_copy['close'].shift(1)) * df_copy['volume']
    fi_ema = fi.ewm(span=window, adjust=False).mean()
    if fillna:
        fi_ema = fi_ema.fillna(0)

    df_copy['fi'] = fi_ema.round(2)

    return df_copy[['fi']]


def MoneyFlowIndex(df: pd.DataFrame, window: int = 14, fillna: bool = False) -> pd.DataFrame:
    """
    Money Flow Index (MFI)

    Uses both price and volume to measure buying and selling pressure.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', 'close', and 'volume' columns.
    - window (int): n period. Default is 14.
    - fillna (bool): if True, fill nan values.

    Call with:
        df['mfi']  = bta.MoneyFlowIndex(df, window=14, fillna=True)['mfi']

    Returns:
    - pd.DataFrame: DataFrame with 'mfi' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate typical price
    typical_price = (df_copy['high'] + df_copy['low'] + df_copy['close']) / 3.0
    up_down = np.where(
        typical_price > typical_price.shift(1),
        1,
        np.where(typical_price < typical_price.shift(1), -1, 0)
    )
    mfr = typical_price * df_copy['volume'] * up_down

    # Calculate positive and negative money flow
    min_periods = 0 if fillna else window
    n_positive_mf = mfr.rolling(window, min_periods=min_periods).apply(
        lambda x: np.sum(np.where(x >= 0.0, x, 0.0)), raw=True
    )
    n_negative_mf = abs(mfr.rolling(window, min_periods=min_periods).apply(
        lambda x: np.sum(np.where(x < 0.0, x, 0.0)), raw=True
    ))

    # Calculate Money Flow Index
    mfi = n_positive_mf / n_negative_mf
    mfi = 100 - (100 / (1 + mfi))
    if fillna:
        mfi = mfi.fillna(50)

    df_copy['mfi'] = mfi.round(2)

    return df_copy[['mfi']]


def NegativeVolumeIndex(df: pd.DataFrame, signal_type: str = 'EMA', signal_length: int = 255, fillna: bool = False) -> pd.DataFrame:
    """
    Negative Volume Index (NVI) with Signal Smoothing

    The Negative Volume Index (NVI) is a technical analysis indicator that measures price changes on days when trading volume decreases compared to the previous day. The theory behind NVI is that prices tend to rise on low volume days as informed traders are more active. The NVI accumulates price rate of change only on days when the volume is lower than the previous day's volume.

    Inspired by: https://www.tradingview.com/script/3Xs25FQc-Negative-Volume-Index-NVI/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - signal_type (str): Type of signal smoothing ('EMA' or 'SMA'). Default is 'EMA'.
    - signal_length (int): Length for the EMA/SMA calculation. Default is 255.
    - fillna (bool): If True, fill nan values.

    Call with:
        nvi_df = NegativeVolumeIndex(df, signal_type='EMA', signal_length=255, fillna=True)
        df['nvi'] = nvi_df['nvi']
        df['nvi_signal'] = nvi_df['nvi_signal']

    Returns:
    - pd.DataFrame: DataFrame with 'nvi' and 'nvi_signal' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate Rate of Change (ROC)
    df_copy['roc'] = df_copy['close'].pct_change() * 100

    # Initialize NVI column with appropriate dtype
    df_copy['nvi'] = 0.0

    # Calculate NVI
    nvi_condition = df_copy['volume'] < df_copy['volume'].shift(1)
    df_copy.loc[nvi_condition, 'nvi'] = df_copy['roc']
    df_copy['nvi'] = df_copy['nvi'].cumsum().shift(1).fillna(0)

    # Calculate NVI Signal
    if signal_type == 'EMA':
        df_copy['nvi_signal'] = df_copy['nvi'].ewm(span=signal_length, adjust=False).mean()
    elif signal_type == 'SMA':
        df_copy['nvi_signal'] = df_copy['nvi'].rolling(window=signal_length, min_periods=1).mean()
    else:
        raise ValueError(f"Invalid signal_type: {signal_type}. Use 'EMA' or 'SMA'.")

    if fillna:
        df_copy['nvi'] = df_copy['nvi'].fillna(0)
        df_copy['nvi_signal'] = df_copy['nvi_signal'].fillna(0)

    return df_copy[['nvi', 'nvi_signal']]


def OnBalanceVolume(df: pd.DataFrame, signal_type: str = 'SMA', signal_length: int = 21, 
                    show_signal: bool = True, fillna: bool = False) -> pd.DataFrame:
    """
    On Balance Volume (OBV) with Signal Smoothing

    The On Balance Volume (OBV) indicator is a momentum-based technical analysis tool that measures buying and selling pressure. It accumulates volume based on price movements: when the closing price is higher than the previous close, the volume is added to the OBV; when the closing price is lower, the volume is subtracted. This helps to identify trends and confirm price movements, with rising OBV indicating strong buying pressure and falling OBV indicating selling pressure.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - signal_type (str): Type of signal smoothing ('EMA' or 'SMA'). Default is 'SMA'.
    - signal_length (int): Length for the signal smoothing. Default is 21.
    - show_signal (bool): If True, plot the signal line. Default is True.
    - fillna (bool): If True, fill nan values.

    Call with:
        obv_df = bta.OnBalanceVolume(df, signal_type='SMA', signal_length=21, show_signal=True, fillna=True)
        df['obv'] = obv_df['obv']
        df['signal'] = obv_df['signal']

    Returns:
    - pd.DataFrame: DataFrame with 'obv' and 'signal' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate OBV
    df_copy['change'] = df_copy['close'].diff()
    df_copy['obv'] = np.where(df_copy['change'] > 0, df_copy['volume'], 
                              np.where(df_copy['change'] < 0, -df_copy['volume'], 0))
    df_copy['obv'] = df_copy['obv'].cumsum()

    # Calculate Signal
    if signal_type == 'EMA':
        df_copy['signal'] = df_copy['obv'].ewm(span=signal_length, adjust=False).mean()
    elif signal_type == 'SMA':
        df_copy['signal'] = df_copy['obv'].rolling(window=signal_length, min_periods=1).mean()
    else:
        raise ValueError(f"Invalid signal_type: {signal_type}. Use 'EMA' or 'SMA'.")

    if fillna:
        df_copy['obv'] = df_copy['obv'].fillna(0)
        df_copy['signal'] = df_copy['signal'].fillna(0)

    return df_copy[['obv', 'signal']]


def OnBalanceVolumeOscillator(df: pd.DataFrame, length: int = 20, fillna: bool = False) -> pd.DataFrame:
    """
    On Balance Volume (OBV) Oscillator

    The On Balance Volume (OBV) is a technical analysis indicator that measures buying and selling pressure by accumulating volume based on price movements. When the price closes higher than the previous close, the volume is added to the OBV, and when the price closes lower, the volume is subtracted. This helps to identify trends and confirm price movements, with increasing OBV indicating strong buying pressure and decreasing OBV indicating selling pressure.

    Inspired by: https://www.tradingview.com/script/Ox9gyUFA-Indicator-OBV-Oscillator/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - length (int): Length for the EMA calculation. Default is 20.
    - fillna (bool): If True, fill nan values.

    Call with:
        df['obv_osc'] = bta.OnBalanceVolumeOscillator(df, length=20, fillna=True)['obv_oscillator']

    Returns:
    - pd.DataFrame: DataFrame with 'obv_oscillator' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate OBV
    df_copy['change'] = df_copy['close'].diff()
    df_copy['obv'] = np.where(df_copy['change'] > 0, df_copy['volume'], 
                              np.where(df_copy['change'] < 0, -df_copy['volume'], 0))
    df_copy['obv'] = df_copy['obv'].cumsum()

    # Calculate OBV Oscillator
    df_copy['ema_obv'] = df_copy['obv'].ewm(span=length, adjust=False).mean()
    df_copy['obv_oscillator'] = df_copy['obv'] - df_copy['ema_obv']

    if fillna:
        df_copy['obv_oscillator'] = df_copy['obv_oscillator'].fillna(0)

    return df_copy[['obv_oscillator']].round(2)


def PositiveVolumeIndex(df: pd.DataFrame, signal_type: str = 'EMA', signal_length: int = 255, fillna: bool = False) -> pd.DataFrame:
    """
    Positive Volume Index (PVI) with Signal Smoothing

    The Positive Volume Index (PVI) is a technical analysis indicator that measures price changes on days when trading volume increases compared to the previous day. The theory behind PVI suggests that prices tend to rise on high volume days as uninformed traders are more active. The PVI accumulates the price rate of change only on days when the volume is higher than the previous day's volume, helping to identify trends driven by high-volume activity.

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - signal_type (str): Type of signal smoothing ('EMA' or 'SMA'). Default is 'EMA'.
    - signal_length (int): Length for the EMA/SMA calculation. Default is 255.
    - fillna (bool): If True, fill nan values.

    Call with:
        pvi_df = PositiveVolumeIndex(df, signal_type='EMA', signal_length=255, fillna=True)
        df['pvi'] = pvi_df['pvi']
        df['pvi_signal'] = pvi_df['pvi_signal']

    Returns:
    - pd.DataFrame: DataFrame with 'pvi' and 'pvi_signal' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate Rate of Change (ROC)
    df_copy['roc'] = df_copy['close'].pct_change() * 100

    # Initialize PVI column with appropriate dtype
    df_copy['pvi'] = 0.0

    # Calculate PVI
    pvi_condition = df_copy['volume'] > df_copy['volume'].shift(1)
    df_copy.loc[pvi_condition, 'pvi'] = df_copy['roc']
    df_copy['pvi'] = df_copy['pvi'].cumsum().shift(1).fillna(0)

    # Calculate PVI Signal
    if signal_type == 'EMA':
        df_copy['pvi_signal'] = df_copy['pvi'].ewm(span=signal_length, adjust=False).mean()
    elif signal_type == 'SMA':
        df_copy['pvi_signal'] = df_copy['pvi'].rolling(window=signal_length, min_periods=1).mean()
    else:
        raise ValueError(f"Invalid signal_type: {signal_type}. Use 'EMA' or 'SMA'.")

    if fillna:
        df_copy['pvi'] = df_copy['pvi'].fillna(0)
        df_copy['pvi_signal'] = df_copy['pvi_signal'].fillna(0)

    return df_copy[['pvi', 'pvi_signal']]


def PriceVolumeTrend(df: pd.DataFrame, fillna: bool = False, smoothing_factor: int = None, signal_type: str = 'SMA', signal_length: int = 21, dropnans: bool = False) -> pd.DataFrame:
    """
    Price Volume trend (PVT)

    Based on cumulative volume that adds or subtracts a multiple of the percentage change in share price trend. 
    PVT = [((CurrentClose - PreviousClose) / PreviousClose) x Volume] + PreviousPVT
    Inspired by: https://www.tradingview.com/script/3Ah2ALck-Price-Volume-Trend/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'close' and 'volume' columns.
    - fillna (bool): If True, fill nan values.
    - smoothing_factor (int, optional): Will smooth PVT implementation with SMA.
    - signal_type (str): Type of signal smoothing ('SMA' or 'EMA').
    - signal_length (int): Length of the signal smoothing.
    - dropnans (bool): Drop nans after indicator calculated.

    Call with:
        pvt_df = bta.PriceVolumeTrend(df, fillna=True, signal_type='EMA', signal_length=21, dropnans=True)
        df['pvt'] = pvt_df['price_volume_trend']
        df['pvt_signal'] = pvt_df['signal']

    Returns:
    - pd.DataFrame: DataFrame with 'price_volume_trend' and 'signal' columns.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Initialize PVT column
    df_copy['price_volume_trend'] = 0.0

    # Calculate PVT iteratively
    for i in range(1, len(df_copy)):
        prev_pvt = df_copy.at[i-1, 'price_volume_trend']
        price_change = (df_copy.at[i, 'close'] - df_copy.at[i-1, 'close']) / df_copy.at[i-1, 'close']
        df_copy.at[i, 'price_volume_trend'] = price_change * df_copy.at[i, 'volume'] + prev_pvt

    if smoothing_factor:
        min_periods = 0 if fillna else smoothing_factor
        df_copy['price_volume_trend'] = df_copy['price_volume_trend'].rolling(smoothing_factor, min_periods=min_periods).mean()
    if dropnans:
        df_copy['price_volume_trend'] = df_copy['price_volume_trend'].dropna()
    if fillna:
        df_copy['price_volume_trend'] = df_copy['price_volume_trend'].fillna(0)

    # Calculate signal
    if signal_type == 'SMA':
        df_copy['signal'] = df_copy['price_volume_trend'].rolling(window=signal_length, min_periods=1 if fillna else signal_length).mean()
    elif signal_type == 'EMA':
        df_copy['signal'] = df_copy['price_volume_trend'].ewm(span=signal_length, adjust=False, min_periods=1 if fillna else signal_length).mean()
    else:
        raise ValueError("signal_type must be either 'SMA' or 'EMA'")

    if dropnans:
        df_copy['signal'] = df_copy['signal'].dropna()
    if fillna:
        df_copy['signal'] = df_copy['signal'].fillna(0)

    df_copy['price_volume_trend'] = df_copy['price_volume_trend'].round(2)
    df_copy['signal'] = df_copy['signal'].round(2)

    return df_copy[['price_volume_trend', 'signal']]


def VolumeWeightedAveragePrice(df: pd.DataFrame, window: int = 14, fillna: bool = False) -> pd.DataFrame:
    """
    Volume Weighted Average Price (VWAP)
    Equals the dollar value of all trading periods divided by the total trading volume for the current day.

    Inspired by: https://www.tradingview.com/script/rSTNnV6B-VWAP-with-period/

    Parameters:
    - df (pandas.DataFrame): Input DataFrame which should contain 'high', 'low', 'close', and 'volume' columns.
    - window (int): n period.
    - fillna (bool): If True, fill nan values.

    Call with:
        df['vwap'] = bta.VolumeWeightedAveragePrice(df, window=14, fillna=True)['volume_weighted_average_price']

    Returns:
    - pd.DataFrame: DataFrame with 'volume_weighted_average_price' column.
    """
    df_copy = df.copy()

    # Ensure the DataFrame contains the required columns
    required_columns = ['high', 'low', 'close', 'volume']
    for col in required_columns:
        if col not in df.columns:
            raise KeyError(f"DataFrame must contain '{col}' column")

    # Calculate typical price
    typical_price = (df_copy['high'] + df_copy['low'] + df_copy['close']) / 3.0
    typical_price_volume = typical_price * df_copy['volume']

    min_periods = 0 if fillna else window
    total_pv = typical_price_volume.rolling(window, min_periods=min_periods).sum()
    total_volume = df_copy['volume'].rolling(window, min_periods=min_periods).sum()

    vwap = total_pv / total_volume
    if fillna:
        vwap = vwap.fillna(0)

    df_copy['volume_weighted_average_price'] = vwap.round(2)
    return df_copy[['volume_weighted_average_price']]


        ----- End of volume.py -----

        __init__.py

        ----- Start of __init__.py -----

# -*- coding: utf-8 -*-
from bamboo_ta.bamboo_ta import *
import numpy as np
from pandas import DataFrame
import pandas as pd

name = "bamboo_ta"
"""
.. moduleauthor:: DutchCryptoDad
"""

        ----- End of __init__.py -----

    docs/
        candles.md

        ----- Start of candles.md -----

# Bamboo TA Indicators Module

## Candles

Contains indicators related to candlestick patterns.

### Indicators

- **HeikinAshi**: Heikin Ashi candlesticks with optional pre and post smoothing.
- **Usage**: 
    ```python
    ha_df = HeikinAshi(df, pre_smoothing_period=14, post_smoothing_period=14)
    df['HA_Close'] = ha_df['HA_Close']
    df['HA_Open'] = ha_df['HA_Open']
    df['HA_High'] = ha_df['HA_High']
    df['HA_Low'] = ha_df['HA_Low']
    ```
- **LinRegCandles**: Linear Regression Candles with optional signal line.
- **Usage**: 
    ```python
    lr_df = LinRegCandles(df, linreg_length=11, sma_signal=True, signal_length=11)
    df['LRC_Open'] = lr_df['bopen']
    df['LRC_High'] = lr_df['bhigh']
    df['LRC_Low'] = lr_df['blow']
    df['LRC_Close'] = lr_df['bclose']
    df['LRC_Signal'] = lr_df['signal']
    ```
- **Exhaustion_Bars**: Leledc Exhaustion Bars - Extended.
- **Usage**: 
    ```python
    exhaustion = Exhaustion_Bars(df)
    df['leledc_major'] = exhaustion['leledc_major']
    df['leledc_minor'] = exhaustion['leledc_minor']
    ```
- **Dynamic_Exhaustion_Bars**: Dynamic Leledc Exhaustion Bars.
- **Usage**: 
    ```python
    dynamic_exhaustion = Dynamic_Exhaustion_Bars(df)
    df['dynamic_leledc_major'] = dynamic_exhaustion['leledc_major']
    df['dynamic_leledc_minor'] = dynamic_exhaustion['leledc_minor']
    ```
- **Pinbar**: Price Action Indicator.
- **Usage**: 
    ```python
    pin = Pinbar(df)
    df['pinbar_sell'] = pin['pinbar_sell']
    df['pinbar_buy'] = pin['pinbar_buy']
    ```

2. **cycles**
   - **Description**: Includes indicators for cycle analysis.

3. **momentum**
   - **Description**: Provides momentum-based indicators.
   - **Indicators**:
     - **CMO**: Chande Momentum Oscillator.
       - **Usage**: 
         ```python
         cmo = CMO(df, length=14)
         df['cmo'] = cmo['cmo']
         ```
     - **EWO**: Elliott Wave Oscillator.
       - **Usage**: 
         ```python
         df['ewo'] = EWO(df, "close", 5, 35)
         ```
     - **MACD**: Moving Average Convergence Divergence.
       - **Usage**: 
         ```python
         macd_result = MACD(df, "close", 12, 26, 9)
         df['macd'] = macd_result['MACD']
         df['macd_signal'] = macd_result['MACD_signal']
         df['macd_histogram'] = macd_result['MACD_histogram']
         ```
     - **MACD_Leader**: MACD Leader.
       - **Usage**: 
         ```python
         macd_leader = MACD_Leader(df, 'close')
         df['macd_leader'] = macd_leader['macd_leader']
         ```
     - **Inverse_Fisher_Transform**: Inverse Fisher Transform.
       - **Usage**: 
         ```python
         ift = Inverse_Fisher_Transform(df)
         df['ift'] = ift['ift']
         # Optional levels
         df['level_1_35'] = 1.35
         df['level_0_5'] = 0.5
         df['level_0'] = 0
         df['level_minus_0_5'] = -0.5
         df['level_minus_1'] = -1
         ```
     - **Waddah_Attar_Explosion**: Waddah Attar Explosion Indicator.
       - **Usage**: 
         ```python
         WAE = Waddah_Attar_Explosion(df, sensitivity=150, fast_length=20, slow_length=40, channel_length=20, mult=2.0)
         df['trend_up'] = WAE['trend_up']
         df['trend_down'] = WAE['trend_down']
         df['explosion_line'] = WAE['explosion_line']
         df['dead_zone_line'] = WAE['dead_zone_line']
         ```
     - **WaveTrend_Oscillator**: WaveTrend Oscillator.
       - **Usage**: 
         ```python
         wt = WaveTrend_Oscillator(df, 'close', n1=8, n2=12)
         df['wavetrend'] = wt['wavetrend']
         ```
     - **RSI**: Relative Strength Index.
       - **Usage**: 
         ```python
         df['rsi'] = RSI(df, "close", 14)
         ```
     - **Fisher_cg**: Fisher Stochastic Center of Gravity.
       - **Usage**: 
         ```python
         fisher = Fisher_cg(df)
         df['fisher_cg'] = fisher['fisher_cg']
         df['fisher_sig'] = fisher['fisher_sig']
         ```
     - **QQE_Mod**: QQE Mod Indicator.
       - **Usage**: 
         ```python
         qqe_mod = QQE_Mod(df, rsi_period=6, rsi_smoothing=5, qqe_factor=3, threshold=3, bollinger_length=50, bb_multiplier=0.35,
                           rsi_period2=6, rsi_smoothing2=5, qqe_factor2=1.61, threshold2=3)
         df['QQE_Line'] = qqe_mod['QQE_Line']
         df['Histo2'] = qqe_mod['Histo2']
         df['QQE_Up'] = qqe_mod['QQE_Up']
         df['QQE_Down'] = qqe_mod['QQE_Down']
         ```
     - **MAStreak**: MA Streak Indicator.
       - **Usage**: 
         ```python
         df['mastreak'] = MAStreak(df, period=4, column='close')
         ```
     - **RMI**: Relative Momentum Index.
       - **Usage**: 
         ```python
         df['rmi'] = RMI(df, length=20, mom=5)
         ```
     - **ROC**: Rate of Change.
       - **Usage**: 
         ```python
         df['roc'] = ROC(df, column='close', period=21)
         ```
     - **SROC**: Smoothed Rate of Change.
       - **Usage**: 
         ```python
         df['sroc'] = SROC(df, roclen=21, emalen=13, smooth=21)
         ```

4. **performance**
   - **Description**: Contains performance-related indicators.

5. **statistics**
   - **Description**: Statistical indicators for trading analysis.

6. **trend**
   - **Description**: Includes trend-based indicators.
   - **Indicators**:
     - **AlligatorBands**: Bill Williams Alligator Indicator.
       - **Usage**: 
         ```python
         alligator_result = AlligatorBands(df, "high", 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
         df['jaw'] = alligator_result['jaw']
         df['teeth'] = alligator_result['teeth']
         df['lips'] = alligator_result['lips']
         ```
     - **BollingerTrend**: Bollinger Trend Indicator.
       - **Usage**: 
         ```python
         df['BBTrend'] = BollingerTrend(df, "close", 20, 50, 2.0)
         ```
     - **BollingerTrendFastWithMA**: Bollinger Trend Indicator with selectable Moving Average.
       - **Usage**: 
         ```python
         result = BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
         df['BBTrend'] = result['BBTrend']
         df['BBTrendMA'] = result['BBTrendMA']
         ```
     - **EMA**: Exponential Moving Average.
       - **Usage**: 
         ```python
         df['ema'] = EMA(df, "close", 21)
         ```
     - **HMA**: Hull Moving Average.
       - **Usage**: 
         ```python
         df['hma'] = HMA(df, "close", 9)
         ```
     - **LSMA**: Least Squares Moving Average.
       - **Usage**: 
         ```python
         df['lsma'] = LSMA(df, "close", 50)
         ```
     - **SMA**: Simple Moving Average.
       - **Usage**: 
         ```python
         df['sma'] = SMA(df, "close", 50)
         ```
     - **WMA**: Weighted Moving Average.
       - **Usage**: 
         ```python
         df['wma'] = WMA(df, "close", 9)
         ```
     - **ZLEMA**: Zero Lag Exponential Moving Average.
       - **Usage**: 
         ```python
         df['zlema'] = ZLEMA(df, "close", 21)
         ```
     - **Breakouts**: S/R Breakouts and Retests.
       - **Usage**: 
         ```python
         breakout = Breakouts(df)
         df['support_level'] = breakout['support_level']
         df['resistance_level'] = breakout['resistance_level']
         df['support_breakout'] = breakout['support_breakout']
         df['resistance_breakout'] = breakout['resistance_breakout']
         df['support_retest'] = breakout['support_retest']
         df['potential_support_retest'] = breakout['potential_support_retest']
         df['resistance_retest'] = breakout['resistance_retest']
         df['potential_resistance_retest'] = breakout['potential_resistance_retest']
         ```
     - **SSLChannels**: SSL Channels.
       - **Usage**: 
         ```python
         ssl_down, ssl_up = SSLChannels(df, length=10, mode='sma')
         df['ssl_down'] = ssl_down
         df['ssl_up'] = ssl_up
         ```
     - **SSLChannelsATR**: SSL Channels with ATR.
       - **Usage**: 
         ```python
         ssl_down, ssl_up = SSLChannelsATR(df, length=7)
         df['ssl_atr_down'] = ssl_down
         df['ssl_atr_up'] = ssl_up
         ```
     - **PCC**: Percent Change Channel.
       - **Usage**: 
         ```python
         upper, rangema, lower = PCC(df, period=20, mult=2)
         df['pcc_upper'] = upper
         df['pcc_rangema'] = rangema
         df['pcc_lower'] = lower
         ```
     - **T3**: T3 Average.
       - **Usage**: 
         ```python
         df['t3_average'] = T3(df, length=5)
         ```

7. **utility**
   - **Description**: Utility functions and helper methods for technical analysis.
   - **Functions**:
     - **Calculate_Exhaustion_Candles**: Calculate the average consecutive length of ups and downs.
       - **Usage**:
         ```python
         maj_qual, min_qual = Calculate_Exhaustion_Candles(df, window, zscore_multi)
         ```
     - **Calculate_Exhaustion_Lengths**: Calculate the average length of peaks and valleys.
       - **Usage**:
         ```python
         maj_len, min_len = Calculate_Exhaustion_Lengths(df)
         ```
     - **Consecutive_Count**: Calculate the average consecutive count of non-zero differences.
       - **Usage**:
         ```python
         avg_consecutive = Consecutive_Count(consecutive_diff)
         ```
     - **Linear_Growth**: Simple linear growth function.
       - **Usage**:
         ```python
         growth_value = Linear_Growth(start, end, start_time, end_time, trade_time)
         ```
     - **Linear_Decay**: Simple linear decay function.
       - **Usage**:
         ```python
         decay_value = Linear_Decay(start, end, start_time, end_time, trade_time)
         ```
     - **populate_leledc_major_minor**: Populate Leledc Major and Minor columns.
       - **Usage**:
         ```python
         df = populate_leledc_major_minor(df, maj_qual, min_qual, maj_len, min_len)
         ```
     - **True_Range**: Calculate True Range (TR).
       - **Usage**:
         ```python
         tr = True_Range(df)
         ```
     - **ZScore**: Calculate the z-score of a series.
       - **Usage**:
         ```python
         zscore = ZScore(series, window=500)
         ```
     - **ATR**: Calculate the Average True Range (ATR).
       - **Usage**:
         ```python
         atr = ATR(df, period=14)
         ```
     - **RMA**: Calculate the Relative Moving Average (RMA).
       - **Usage**:
         ```python
         rma = RMA(series, period)
         ```

8. **volatility**
   - **Description**: Volatility indicators.
   - **Indicators**:
     - **BollingerBands**: Calculates Bollinger Bands (upper, middle, lower bands).
       - **Usage**: 
         ```python
         bb_result = BollingerBands(df, "close", 21, 2, 0)
         df['bb_upper'] = bb_result['BB_upper']
         df['bb_middle'] = bb_result['BB_middle']
         df['bb_lower'] = bb_result['BB_lower']
         ```
     - **TR**: True Range (TR) calculation.
       - **Usage**: 
         ```python
         tr = TR(df)
         ```

9. **volume**
   - **Description**: Provides volume-based indicators.
   - **Indicators**:
     - **OBV_Oscillator**: On Balance Volume Oscillator.
       - **Usage**:
         ```python
         obv_osc = OBV_Oscillator(df, n1=10, n2=21)
         df['OBV_Oscillator'] = obv_osc['OBV_Oscillator']
         ```
        ----- End of candles.md -----

        cycles.md

        ----- Start of cycles.md -----

# Bamboo TA Indicators Module

## Cycles

Includes indicators for cycle analysis.


        ----- End of cycles.md -----

        momentum.md

        ----- Start of momentum.md -----

# Bamboo TA Indicators Module

## Momentum

Provides momentum-based indicators.

### Indicators

- **CMO**: Chande Momentum Oscillator.
- **Usage**: 
    ```python
    cmo = CMO(df, length=14)
    df['cmo'] = cmo['cmo']
    ```
- **EWO**: Elliott Wave Oscillator.
- **Usage**: 
    ```python
    df['ewo'] = EWO(df, "close", 5, 35)
    ```
- **MACD**: Moving Average Convergence Divergence.
- **Usage**: 
    ```python
    macd_result = MACD(df, "close", 12, 26, 9)
    df['macd'] = macd_result['MACD']
    df['macd_signal'] = macd_result['MACD_signal']
    df['macd_histogram'] = macd_result['MACD_histogram']
    ```
- **MACD_Leader**: MACD Leader.
- **Usage**: 
    ```python
    macd_leader = MACD_Leader(df, 'close')
    df['macd_leader'] = macd_leader['macd_leader']
    ```
- **Inverse_Fisher_Transform**: Inverse Fisher Transform.
- **Usage**: 
    ```python
    ift = Inverse_Fisher_Transform(df)
    df['ift'] = ift['ift']
    # Optional levels
    df['level_1_35'] = 1.35
    df['level_0_5'] = 0.5
    df['level_0'] = 0
    df['level_minus_0_5'] = -0.5
    df['level_minus_1'] = -1
    ```
- **Waddah_Attar_Explosion**: Waddah Attar Explosion Indicator.
- **Usage**: 
    ```python
    WAE = Waddah_Attar_Explosion(df, sensitivity=150, fast_length=20, slow_length=40, channel_length=20, mult=2.0)
    df['trend_up'] = WAE['trend_up']
    df['trend_down'] = WAE['trend_down']
    df['explosion_line'] = WAE['explosion_line']
    df['dead_zone_line'] = WAE['dead_zone_line']
    ```
- **WaveTrend_Oscillator**: WaveTrend Oscillator.
- **Usage**: 
    ```python
    wt = WaveTrend_Oscillator(df, 'close', n1=8, n2=12)
    df['wavetrend'] = wt['wavetrend']
    ```
- **RSI**: Relative Strength Index.
- **Usage**: 
    ```python
    df['rsi'] = RSI(df, "close", 14)
    ```
- **Fisher_cg**: Fisher Stochastic Center of Gravity.
- **Usage**: 
    ```python
    fisher = Fisher_cg(df)
    df['fisher_cg'] = fisher['fisher_cg']
    df['fisher_sig'] = fisher['fisher_sig']
    ```
- **QQE_Mod**: QQE Mod Indicator.
- **Usage**: 
    ```python
    qqe_mod = QQE_Mod(df, rsi_period=6, rsi_smoothing=5, qqe_factor=3, threshold=3, bollinger_length=50, bb_multiplier=0.35,
                    rsi_period2=6, rsi_smoothing2=5, qqe_factor2=1.61, threshold2=3)
    df['QQE_Line'] = qqe_mod['QQE_Line']
    df['Histo2'] = qqe_mod['Histo2']
    df['QQE_Up'] = qqe_mod['QQE_Up']
    df['QQE_Down'] = qqe_mod['QQE_Down']
    ```
- **MAStreak**: MA Streak Indicator.
- **Usage**: 
    ```python
    df['mastreak'] = MAStreak(df, period=4, column='close')
    ```
- **RMI**: Relative Momentum Index.
- **Usage**: 
    ```python
    df['rmi'] = RMI(df, length=20, mom=5)
    ```
- **ROC**: Rate of Change.
- **Usage**: 
    ```python
    df['roc'] = ROC(df, column='close', period=21)
    ```
- **SROC**: Smoothed Rate of Change.
- **Usage**: 
    ```python
    df['sroc'] = SROC(df, roclen=21, emalen=13, smooth=21)
    ```

4. **performance**
   - **Description**: Contains performance-related indicators.

5. **statistics**
   - **Description**: Statistical indicators for trading analysis.

6. **trend**
   - **Description**: Includes trend-based indicators.
   - **Indicators**:
     - **AlligatorBands**: Bill Williams Alligator Indicator.
       - **Usage**: 
         ```python
         alligator_result = AlligatorBands(df, "high", 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
         df['jaw'] = alligator_result['jaw']
         df['teeth'] = alligator_result['teeth']
         df['lips'] = alligator_result['lips']
         ```
     - **BollingerTrend**: Bollinger Trend Indicator.
       - **Usage**: 
         ```python
         df['BBTrend'] = BollingerTrend(df, "close", 20, 50, 2.0)
         ```
     - **BollingerTrendFastWithMA**: Bollinger Trend Indicator with selectable Moving Average.
       - **Usage**: 
         ```python
         result = BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
         df['BBTrend'] = result['BBTrend']
         df['BBTrendMA'] = result['BBTrendMA']
         ```
     - **EMA**: Exponential Moving Average.
       - **Usage**: 
         ```python
         df['ema'] = EMA(df, "close", 21)
         ```
     - **HMA**: Hull Moving Average.
       - **Usage**: 
         ```python
         df['hma'] = HMA(df, "close", 9)
         ```
     - **LSMA**: Least Squares Moving Average.
       - **Usage**: 
         ```python
         df['lsma'] = LSMA(df, "close", 50)
         ```
     - **SMA**: Simple Moving Average.
       - **Usage**: 
         ```python
         df['sma'] = SMA(df, "close", 50)
         ```
     - **WMA**: Weighted Moving Average.
       - **Usage**: 
         ```python
         df['wma'] = WMA(df, "close", 9)
         ```
     - **ZLEMA**: Zero Lag Exponential Moving Average.
       - **Usage**: 
         ```python
         df['zlema'] = ZLEMA(df, "close", 21)
         ```
     - **Breakouts**: S/R Breakouts and Retests.
       - **Usage**: 
         ```python
         breakout = Breakouts(df)
         df['support_level'] = breakout['support_level']
         df['resistance_level'] = breakout['resistance_level']
         df['support_breakout'] = breakout['support_breakout']
         df['resistance_breakout'] = breakout['resistance_breakout']
         df['support_retest'] = breakout['support_retest']
         df['potential_support_retest'] = breakout['potential_support_retest']
         df['resistance_retest'] = breakout['resistance_retest']
         df['potential_resistance_retest'] = breakout['potential_resistance_retest']
         ```
     - **SSLChannels**: SSL Channels.
       - **Usage**: 
         ```python
         ssl_down, ssl_up = SSLChannels(df, length=10, mode='sma')
         df['ssl_down'] = ssl_down
         df['ssl_up'] = ssl_up
         ```
     - **SSLChannelsATR**: SSL Channels with ATR.
       - **Usage**: 
         ```python
         ssl_down, ssl_up = SSLChannelsATR(df, length=7)
         df['ssl_atr_down'] = ssl_down
         df['ssl_atr_up'] = ssl_up
         ```
     - **PCC**: Percent Change Channel.
       - **Usage**: 
         ```python
         upper, rangema, lower = PCC(df, period=20, mult=2)
         df['pcc_upper'] = upper
         df['pcc_rangema'] = rangema
         df['pcc_lower'] = lower
         ```
     - **T3**: T3 Average.
       - **Usage**: 
         ```python
         df['t3_average'] = T3(df, length=5)
         ```

7. **utility**
   - **Description**: Utility functions and helper methods for technical analysis.
   - **Functions**:
     - **Calculate_Exhaustion_Candles**: Calculate the average consecutive length of ups and downs.
       - **Usage**:
         ```python
         maj_qual, min_qual = Calculate_Exhaustion_Candles(df, window, zscore_multi)
         ```
     - **Calculate_Exhaustion_Lengths**: Calculate the average length of peaks and valleys.
       - **Usage**:
         ```python
         maj_len, min_len = Calculate_Exhaustion_Lengths(df)
         ```
     - **Consecutive_Count**: Calculate the average consecutive count of non-zero differences.
       - **Usage**:
         ```python
         avg_consecutive = Consecutive_Count(consecutive_diff)
         ```
     - **Linear_Growth**: Simple linear growth function.
       - **Usage**:
         ```python
         growth_value = Linear_Growth(start, end, start_time, end_time, trade_time)
         ```
     - **Linear_Decay**: Simple linear decay function.
       - **Usage**:
         ```python
         decay_value = Linear_Decay(start, end, start_time, end_time, trade_time)
         ```
     - **populate_leledc_major_minor**: Populate Leledc Major and Minor columns.
       - **Usage**:
         ```python
         df = populate_leledc_major_minor(df, maj_qual, min_qual, maj_len, min_len)
         ```
     - **True_Range**: Calculate True Range (TR).
       - **Usage**:
         ```python
         tr = True_Range(df)
         ```
     - **ZScore**: Calculate the z-score of a series.
       - **Usage**:
         ```python
         zscore = ZScore(series, window=500)
         ```
     - **ATR**: Calculate the Average True Range (ATR).
       - **Usage**:
         ```python
         atr = ATR(df, period=14)
         ```
     - **RMA**: Calculate the Relative Moving Average (RMA).
       - **Usage**:
         ```python
         rma = RMA(series, period)
         ```

8. **volatility**
   - **Description**: Volatility indicators.
   - **Indicators**:
     - **BollingerBands**: Calculates Bollinger Bands (upper, middle, lower bands).
       - **Usage**: 
         ```python
         bb_result = BollingerBands(df, "close", 21, 2, 0)
         df['bb_upper'] = bb_result['BB_upper']
         df['bb_middle'] = bb_result['BB_middle']
         df['bb_lower'] = bb_result['BB_lower']
         ```
     - **TR**: True Range (TR) calculation.
       - **Usage**: 
         ```python
         tr = TR(df)
         ```

9. **volume**
   - **Description**: Provides volume-based indicators.
   - **Indicators**:
     - **OBV_Oscillator**: On Balance Volume Oscillator.
       - **Usage**:
         ```python
         obv_osc = OBV_Oscillator(df, n1=10, n2=21)
         df['OBV_Oscillator'] = obv_osc['OBV_Oscillator']
         ```
        ----- End of momentum.md -----

        performance.md

        ----- Start of performance.md -----

# Bamboo TA Indicators Module

## Performance

Contains performance-related indicators.

### Indicators


        ----- End of performance.md -----

        statistics.md

        ----- Start of statistics.md -----

# Bamboo TA Indicators Module

## Statistics

Statistical indicators for trading analysis.

### Indicators


        ----- End of statistics.md -----

        trend.md

        ----- Start of trend.md -----

# Bamboo TA Indicators Module

## Trend

Includes trend-based indicators.

### Indicators

- **AlligatorBands**: Bill Williams Alligator Indicator.
- **Usage**: 
    ```python
    alligator_result = AlligatorBands(df, "high", 13, 8, 5, jaw_shift=8, teeth_shift=5, lips_shift=3)
    df['jaw'] = alligator_result['jaw']
    df['teeth'] = alligator_result['teeth']
    df['lips'] = alligator_result['lips']
    ```
- **BollingerTrend**: Bollinger Trend Indicator.
- **Usage**: 
    ```python
    df['BBTrend'] = BollingerTrend(df, "close", 20, 50, 2.0)
    ```
- **BollingerTrendFastWithMA**: Bollinger Trend Indicator with selectable Moving Average.
- **Usage**: 
    ```python
    result = BollingerTrendFastWithMA(df, column="close", short_length=10, long_length=50, short_stddev=1.0, long_stddev=2.0, ma_type="SMA", ma_length=14)
    df['BBTrend'] = result['BBTrend']
    df['BBTrendMA'] = result['BBTrendMA']
    ```
- **EMA**: Exponential Moving Average.
- **Usage**: 
    ```python
    df['ema'] = EMA(df, "close", 21)
    ```
- **HMA**: Hull Moving Average.
- **Usage**: 
    ```python
    df['hma'] = HMA(df, "close", 9)
    ```
- **LSMA**: Least Squares Moving Average.
- **Usage**: 
    ```python
    df['lsma'] = LSMA(df, "close", 50)
    ```
- **SMA**: Simple Moving Average.
- **Usage**: 
    ```python
    df['sma'] = SMA(df, "close", 50)
    ```
- **WMA**: Weighted Moving Average.
- **Usage**: 
    ```python
    df['wma'] = WMA(df, "close", 9)
    ```
- **ZLEMA**: Zero Lag Exponential Moving Average.
- **Usage**: 
    ```python
    df['zlema'] = ZLEMA(df, "close", 21)
    ```
- **Breakouts**: S/R Breakouts and Retests.
- **Usage**: 
    ```python
    breakout = Breakouts(df)
    df['support_level'] = breakout['support_level']
    df['resistance_level'] = breakout['resistance_level']
    df['support_breakout'] = breakout['support_breakout']
    df['resistance_breakout'] = breakout['resistance_breakout']
    df['support_retest'] = breakout['support_retest']
    df['potential_support_retest'] = breakout['potential_support_retest']
    df['resistance_retest'] = breakout['resistance_retest']
    df['potential_resistance_retest'] = breakout['potential_resistance_retest']
    ```
- **SSLChannels**: SSL Channels.
- **Usage**: 
    ```python
    ssl_down, ssl_up = SSLChannels(df, length=10, mode='sma')
    df['ssl_down'] = ssl_down
    df['ssl_up'] = ssl_up
    ```
- **SSLChannelsATR**: SSL Channels with ATR.
- **Usage**: 
    ```python
    ssl_down, ssl_up = SSLChannelsATR(df, length=7)
    df['ssl_atr_down'] = ssl_down
    df['ssl_atr_up'] = ssl_up
    ```
- **PCC**: Percent Change Channel.
- **Usage**: 
    ```python
    upper, rangema, lower = PCC(df, period=20, mult=2)
    df['pcc_upper'] = upper
    df['pcc_rangema'] = rangema
    df['pcc_lower'] = lower
    ```
- **T3**: T3 Average.
- **Usage**: 
    ```python
    df['t3_average'] = T3(df, length=5)
    ```

        ----- End of trend.md -----

        utility.md

        ----- Start of utility.md -----

# Bamboo TA Indicators Module

## Utility

Utility functions and helper methods for technical analysis.

### Indicators

- **Calculate_Exhaustion_Candles**: Calculate the average consecutive length of ups and downs.
- **Usage**:
    ```python
    maj_qual, min_qual = Calculate_Exhaustion_Candles(df, window, zscore_multi)
    ```
- **Calculate_Exhaustion_Lengths**: Calculate the average length of peaks and valleys.
- **Usage**:
    ```python
    maj_len, min_len = Calculate_Exhaustion_Lengths(df)
    ```
- **Consecutive_Count**: Calculate the average consecutive count of non-zero differences.
- **Usage**:
    ```python
    avg_consecutive = Consecutive_Count(consecutive_diff)
    ```
- **Linear_Growth**: Simple linear growth function.
- **Usage**:
    ```python
    growth_value = Linear_Growth(start, end, start_time, end_time, trade_time)
    ```
- **Linear_Decay**: Simple linear decay function.
- **Usage**:
    ```python
    decay_value = Linear_Decay(start, end, start_time, end_time, trade_time)
    ```
- **populate_leledc_major_minor**: Populate Leledc Major and Minor columns.
- **Usage**:
    ```python
    df = populate_leledc_major_minor(df, maj_qual, min_qual, maj_len, min_len)
    ```
- **True_Range**: Calculate True Range (TR).
- **Usage**:
    ```python
    tr = True_Range(df)
    ```
- **ZScore**: Calculate the z-score of a series.
- **Usage**:
    ```python
    zscore = ZScore(series, window=500)
    ```
- **ATR**: Calculate the Average True Range (ATR).
- **Usage**:
    ```python
    atr = ATR(df, period=14)
    ```
- **RMA**: Calculate the Relative Moving Average (RMA).
- **Usage**:
    ```python
    rma = RMA(series, period)
    ```

        ----- End of utility.md -----

        volatility.md

        ----- Start of volatility.md -----

# Bamboo TA Indicators Module

## Volatility

Volatility indicators.

### Indicators

- **BollingerBands**: Calculates Bollinger Bands (upper, middle, lower bands).
- **Usage**: 
    ```python
    bb_result = BollingerBands(df, "close", 21, 2, 0)
    df['bb_upper'] = bb_result['BB_upper']
    df['bb_middle'] = bb_result['BB_middle']
    df['bb_lower'] = bb_result['BB_lower']
    ```
- **TR**: True Range (TR) calculation.
- **Usage**: 
    ```python
    tr = TR(df)
    ```

        ----- End of volatility.md -----

        volume.md

        ----- Start of volume.md -----

# Bamboo TA Indicators Module

## Volume

Provides volume-based indicators.

### Indicators

- **OBV_Oscillator**: On Balance Volume Oscillator.
- **Usage**:
    ```python
    obv_osc = OBV_Oscillator(df, n1=10, n2=21)
    df['OBV_Oscillator'] = obv_osc['OBV_Oscillator']
    ```
        ----- End of volume.md -----

